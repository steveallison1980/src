{"ast":null,"code":"import _toArray from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _toConsumableArray from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { queueScheduler, asyncScheduler } from 'rxjs';\nimport { tap, subscribeOn, observeOn } from 'rxjs/operators';\nimport { InjectionToken, Version, isDevMode, NgZone, Optional, VERSION as VERSION$1, NgModule, Inject, PLATFORM_ID } from '@angular/core';\nimport firebase from 'firebase/app';\n/**\n * @fileoverview added by tsickle\n * Generated from: angularfire2.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction noop() {}\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\n// tslint:disable-next-line:class-name\n\n\nvar ɵZoneScheduler = /*#__PURE__*/function () {\n  /**\n   * @param {?} zone\n   * @param {?=} delegate\n   */\n  function ɵZoneScheduler(zone) {\n    var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : queueScheduler;\n\n    _classCallCheck(this, ɵZoneScheduler);\n\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(ɵZoneScheduler, [{\n    key: \"now\",\n    value: function now() {\n      return this.delegate.now();\n    }\n    /**\n     * @param {?} work\n     * @param {?=} delay\n     * @param {?=} state\n     * @return {?}\n     */\n\n  }, {\n    key: \"schedule\",\n    value: function schedule(work, delay, state) {\n      /** @type {?} */\n      var targetZone = this.zone; // Wrap the specified work function to make sure that if nested scheduling takes place the\n      // work is executed in the correct zone\n\n      /** @type {?} */\n\n      var workInZone =\n      /**\n      * @this {?}\n      * @param {?} state\n      * @return {?}\n      */\n      function workInZone(state) {\n        var _this = this;\n\n        targetZone.runGuarded(\n        /**\n        * @return {?}\n        */\n        function () {\n          work.apply(_this, [state]);\n        });\n      }; // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n      // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n      // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n\n\n      return this.delegate.schedule(workInZone, delay, state);\n    }\n  }]);\n\n  return ɵZoneScheduler;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ɵZoneScheduler.prototype.zone;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ɵZoneScheduler.prototype.delegate;\n} // tslint:disable-next-line:class-name\n\n/**\n * @template T\n */\n\n\nvar ɵBlockUntilFirstOperator = /*#__PURE__*/function () {\n  /**\n   * @param {?} zone\n   */\n  function ɵBlockUntilFirstOperator(zone) {\n    _classCallCheck(this, ɵBlockUntilFirstOperator);\n\n    this.zone = zone;\n    this.task = null;\n  }\n  /**\n   * @param {?} subscriber\n   * @param {?} source\n   * @return {?}\n   */\n\n\n  _createClass(ɵBlockUntilFirstOperator, [{\n    key: \"call\",\n    value: function call(subscriber, source) {\n      /** @type {?} */\n      var unscheduleTask = this.unscheduleTask.bind(this);\n      this.task = this.zone.run(\n      /**\n      * @return {?}\n      */\n      function () {\n        return Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop);\n      });\n      return source.pipe(tap({\n        next: unscheduleTask,\n        complete: unscheduleTask,\n        error: unscheduleTask\n      })).subscribe(subscriber).add(unscheduleTask);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"unscheduleTask\",\n    value: function unscheduleTask() {\n      var _this2 = this;\n\n      // maybe this is a race condition, invoke in a timeout\n      // hold for 10ms while I try to figure out what is going on\n      setTimeout(\n      /**\n      * @return {?}\n      */\n      function () {\n        if (_this2.task != null && _this2.task.state === 'scheduled') {\n          _this2.task.invoke();\n\n          _this2.task = null;\n        }\n      }, 10);\n    }\n  }]);\n\n  return ɵBlockUntilFirstOperator;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ɵBlockUntilFirstOperator.prototype.task;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ɵBlockUntilFirstOperator.prototype.zone;\n} // tslint:disable-next-line:class-name\n\n\nvar ɵAngularFireSchedulers =\n/**\n * @param {?} ngZone\n */\nfunction ɵAngularFireSchedulers(ngZone) {\n  _classCallCheck(this, ɵAngularFireSchedulers);\n\n  this.ngZone = ngZone;\n  this.outsideAngular = ngZone.runOutsideAngular(\n  /**\n  * @return {?}\n  */\n  function () {\n    return new ɵZoneScheduler(Zone.current);\n  });\n  this.insideAngular = ngZone.run(\n  /**\n  * @return {?}\n  */\n  function () {\n    return new ɵZoneScheduler(Zone.current, asyncScheduler);\n  });\n};\n\nif (false) {\n  /** @type {?} */\n  ɵAngularFireSchedulers.prototype.outsideAngular;\n  /** @type {?} */\n\n  ɵAngularFireSchedulers.prototype.insideAngular;\n  /** @type {?} */\n\n  ɵAngularFireSchedulers.prototype.ngZone;\n}\n/**\n * Operator to block the zone until the first value has been emitted or the observable\n * has completed/errored. This is used to make sure that universal waits until the first\n * value from firebase but doesn't block the zone forever since the firebase subscription\n * is still alive.\n * @param {?} schedulers\n * @return {?}\n */\n\n\nfunction ɵkeepUnstableUntilFirstFactory(schedulers) {\n  return (\n    /**\n    * @template T\n    * @param {?} obs$\n    * @return {?}\n    */\n    function keepUnstableUntilFirst(obs$) {\n      obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));\n      return obs$.pipe( // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)\n      subscribeOn(schedulers.outsideAngular), // Run operators inside the angular zone (e.g. side effects via tap())\n      observeOn(schedulers.insideAngular) // INVESTIGATE https://github.com/angular/angularfire/pull/2315\n      // share()\n      );\n    }\n  );\n} // DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\n\n/** @type {?} */\n\n\nvar noopFunctions = ['ngOnDestroy']; // INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\n\n/** @type {?} */\n\nvar ɵlazySDKProxy =\n/**\n* @param {?} klass\n* @param {?} observable\n* @param {?} zone\n* @param {?=} options\n* @return {?}\n*/\nfunction ɵlazySDKProxy(klass, observable, zone) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Proxy(klass, {\n    get:\n    /**\n    * @param {?} _\n    * @param {?} name\n    * @return {?}\n    */\n    function get(_, name) {\n      return zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        var _a;\n\n        if (klass[name]) {\n          if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.get) {\n            options.spy.get(name, klass[name]);\n          }\n\n          return klass[name];\n        }\n\n        if (noopFunctions.indexOf(name) > -1) {\n          return (\n            /**\n            * @return {?}\n            */\n            function () {}\n          );\n        }\n        /** @type {?} */\n\n\n        var promise = observable.toPromise().then(\n        /**\n        * @param {?} mod\n        * @return {?}\n        */\n\n        /**\n        * @param {?} mod\n        * @return {?}\n        */\n        function (mod) {\n          /** @type {?} */\n          var ret = mod && mod[name]; // TODO move to proper type guards\n\n          if (typeof ret === 'function') {\n            return ret.bind(mod);\n          } else if (ret && ret.then) {\n            return ret.then(\n            /**\n            * @param {?} res\n            * @return {?}\n            */\n            function (res) {\n              return zone.run(\n              /**\n              * @return {?}\n              */\n              function () {\n                return res;\n              });\n            });\n          } else {\n            return zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              return ret;\n            });\n          }\n        }); // recurse the proxy\n\n        return new Proxy(\n        /**\n        * @return {?}\n        */\n        function () {}, {\n          get:\n          /**\n          * @param {?} _\n          * @param {?} name\n          * @return {?}\n          */\n          function get(_, name) {\n            return promise[name];\n          },\n          // TODO handle callbacks as transparently as I can\n          apply:\n          /**\n          * @param {?} self\n          * @param {?} _\n          * @param {?} args\n          * @return {?}\n          */\n          function apply(self, _, args) {\n            return promise.then(\n            /**\n            * @param {?} it\n            * @return {?}\n            */\n\n            /**\n            * @param {?} it\n            * @return {?}\n            */\n            function (it) {\n              var _a;\n              /** @type {?} */\n\n\n              var res = it && it.apply(void 0, _toConsumableArray(args));\n\n              if ((_a = options === null || options === void 0 ? void 0 : options.spy) === null || _a === void 0 ? void 0 : _a.apply) {\n                options.spy.apply(name, args, res);\n              }\n\n              return res;\n            });\n          }\n        });\n      });\n    }\n  });\n};\n/** @type {?} */\n\n\nvar ɵapplyMixins =\n/**\n* @param {?} derivedCtor\n* @param {?} constructors\n* @return {?}\n*/\nfunction ɵapplyMixins(derivedCtor, constructors) {\n  constructors.forEach(\n  /**\n  * @param {?} baseCtor\n  * @return {?}\n  */\n  function (baseCtor) {\n    Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach(\n    /**\n    * @param {?} name\n    * @return {?}\n    */\n    function (name) {\n      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name));\n    });\n  });\n};\n/**\n * @fileoverview added by tsickle\n * Generated from: firebase.app.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction FirebaseOptions() {}\n/**\n * @record\n */\n\n\nfunction FirebaseAppConfig() {}\n/** @type {?} */\n\n\nvar FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');\n/** @type {?} */\n\nvar FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig'); // Have to implement as we need to return a class from the provider, we should consider exporting\n// this in the firebase/app types as this is our highest risk of breaks\n\nvar FirebaseApp = function FirebaseApp() {\n  _classCallCheck(this, FirebaseApp);\n};\n\nif (false) {\n  /** @type {?} */\n  FirebaseApp.prototype.name;\n  /** @type {?} */\n\n  FirebaseApp.prototype.options;\n  /** @type {?} */\n\n  FirebaseApp.prototype.analytics;\n  /** @type {?} */\n\n  FirebaseApp.prototype.auth;\n  /** @type {?} */\n\n  FirebaseApp.prototype.database;\n  /** @type {?} */\n\n  FirebaseApp.prototype.messaging;\n  /** @type {?} */\n\n  FirebaseApp.prototype.performance;\n  /** @type {?} */\n\n  FirebaseApp.prototype.storage;\n  /** @type {?} */\n\n  FirebaseApp.prototype.delete;\n  /** @type {?} */\n\n  FirebaseApp.prototype.firestore;\n  /** @type {?} */\n\n  FirebaseApp.prototype.functions;\n  /** @type {?} */\n\n  FirebaseApp.prototype.remoteConfig;\n}\n/** @type {?} */\n\n\nvar VERSION = new Version('6.1.4');\n/**\n * @param {?} options\n * @param {?} zone\n * @param {?=} nameOrConfig\n * @return {?}\n */\n\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n  /** @type {?} */\n  var name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n  /** @type {?} */\n\n  var config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n  config.name = config.name || name; // Added any due to some inconsistency between @firebase/app and firebase types\n\n  /** @type {?} */\n\n  var existingApp =\n  /** @type {?} */\n  firebase.apps.filter(\n  /**\n  * @param {?} app\n  * @return {?}\n  */\n\n  /**\n  * @param {?} app\n  * @return {?}\n  */\n  function (app) {\n    return app && app.name === config.name;\n  })[0]; // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n  // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n\n  /** @type {?} */\n\n  var app =\n  /** @type {?} */\n  existingApp || zone.runOutsideAngular(\n  /**\n  * @return {?}\n  */\n  function () {\n    return firebase.initializeApp(options,\n    /** @type {?} */\n    config);\n  });\n\n  try {\n    if (JSON.stringify(options) !== JSON.stringify(app.options)) {\n      /** @type {?} */\n      var hmr = !!\n      /** @type {?} */\n      module.hot;\n      log('error', \"\".concat(app.name, \" Firebase App already initialized with different options\").concat(hmr ? ', you may need to reload as Firebase is not HMR aware.' : '.'));\n    }\n  } catch (e) {}\n\n  return app;\n}\n/** @type {?} */\n\n\nvar ɵlogAuthEmulatorError =\n/**\n* @return {?}\n*/\nfunction ɵlogAuthEmulatorError() {\n  // TODO sort this out, https://github.com/angular/angularfire/issues/2656\n  log('warn', 'You may need to import \\'firebase/auth\\' manually in your component rather than rely on AngularFireAuth\\'s dynamic import, when using the emulator suite https://github.com/angular/angularfire/issues/2656');\n};\n/** @type {?} */\n\n\nvar log =\n/**\n* @param {?} level\n* @param {...?} args\n* @return {?}\n*/\nfunction log(level) {\n  if (isDevMode() && typeof console !== 'undefined') {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console)[level].apply(_console, args);\n  }\n};\n\nvar ɵ0 = log;\nglobalThis.ɵAngularfireInstanceCache || (globalThis.ɵAngularfireInstanceCache = new Map());\n/**\n * @template T\n * @param {?} cacheKey\n * @param {?} moduleName\n * @param {?} app\n * @param {?} fn\n * @param {?} args\n * @return {?}\n */\n\nfunction ɵfetchInstance(cacheKey, moduleName, app, fn, args) {\n  var _ref = globalThis.ɵAngularfireInstanceCache.get(cacheKey) || [],\n      _ref2 = _toArray(_ref),\n      instance = _ref2[0],\n      cachedArgs = _ref2.slice(1);\n\n  if (instance) {\n    try {\n      if (args.some(\n      /**\n      * @param {?} arg\n      * @param {?} i\n      * @return {?}\n      */\n      function (arg, i) {\n        /** @type {?} */\n        var cachedArg = cachedArgs[i];\n\n        if (arg && typeof arg === 'object') {\n          return JSON.stringify(arg) !== JSON.stringify(cachedArg);\n        } else {\n          return arg !== cachedArg;\n        }\n      })) {\n        /** @type {?} */\n        var hmr = !!\n        /** @type {?} */\n        module.hot;\n        log('error', \"\".concat(moduleName, \" was already initialized on the \").concat(app.name, \" Firebase App instance with different settings.\").concat(hmr ? ' You may need to reload as Firebase is not HMR aware.' : ''));\n      }\n    } catch (e) {}\n\n    return instance;\n  } else {\n    /** @type {?} */\n    var newInstance = fn();\n    globalThis.ɵAngularfireInstanceCache.set(cacheKey, [newInstance].concat(_toConsumableArray(args)));\n    return newInstance;\n  }\n}\n/** @type {?} */\n\n\nvar FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: ɵfirebaseAppFactory,\n  deps: [FIREBASE_OPTIONS, NgZone, [new Optional(), FIREBASE_APP_NAME]]\n};\n\nvar AngularFireModule = /*@__PURE__*/function () {\n  var AngularFireModule = /*#__PURE__*/function () {\n    // tslint:disable-next-line:ban-types\n\n    /**\n     * @param {?} platformId\n     */\n    function AngularFireModule(platformId) {\n      _classCallCheck(this, AngularFireModule);\n\n      firebase.registerVersion('angularfire', VERSION.full, platformId.toString());\n      firebase.registerVersion('angular', VERSION$1.full);\n    }\n    /**\n     * @param {?} options\n     * @param {?=} nameOrConfig\n     * @return {?}\n     */\n\n\n    _createClass(AngularFireModule, null, [{\n      key: \"initializeApp\",\n      value: function initializeApp(options, nameOrConfig) {\n        return {\n          ngModule: AngularFireModule,\n          providers: [{\n            provide: FIREBASE_OPTIONS,\n            useValue: options\n          }, {\n            provide: FIREBASE_APP_NAME,\n            useValue: nameOrConfig\n          }]\n        };\n      }\n    }]);\n\n    return AngularFireModule;\n  }();\n\n  AngularFireModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireModule\n  });\n  AngularFireModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function AngularFireModule_Factory(t) {\n      return new (t || AngularFireModule)(ɵngcc0.ɵɵinject(PLATFORM_ID));\n    },\n    providers: [FIREBASE_APP_PROVIDER]\n  });\n  return AngularFireModule;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, VERSION, ɵAngularFireSchedulers, ɵBlockUntilFirstOperator, ɵZoneScheduler, ɵapplyMixins, ɵfetchInstance, ɵfirebaseAppFactory, ɵkeepUnstableUntilFirstFactory, ɵlazySDKProxy, ɵlogAuthEmulatorError };","map":null,"metadata":{},"sourceType":"module"}