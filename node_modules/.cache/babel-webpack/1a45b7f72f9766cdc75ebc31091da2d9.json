{"ast":null,"code":"import _defineProperty from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _slicedToArray from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, from, of } from 'rxjs';\nimport { startWith, pairwise, map, scan, distinctUntilChanged, filter, observeOn } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵlogAuthEmulatorError, ɵfetchInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\nimport firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { USE_EMULATOR as USE_EMULATOR$1 } from '@angular/fire/auth';\n/**\n * @fileoverview added by tsickle\n * Generated from: observable/fromRef.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @template T, R\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction _fromRef(ref) {\n  var scheduler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : asyncScheduler;\n  return new Observable(\n  /**\n  * @param {?} subscriber\n  * @return {?}\n  */\n\n  /**\n  * @param {?} subscriber\n  * @return {?}\n  */\n  function (subscriber) {\n    /** @type {?} */\n    var unsubscribe;\n\n    if (scheduler != null) {\n      scheduler.schedule(\n      /**\n      * @return {?}\n      */\n      function () {\n        unsubscribe = ref.onSnapshot({\n          includeMetadataChanges: true\n        }, subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot({\n        includeMetadataChanges: true\n      }, subscriber);\n    }\n\n    return (\n      /**\n      * @return {?}\n      */\n      function () {\n        if (unsubscribe != null) {\n          unsubscribe();\n        }\n      }\n    );\n  });\n}\n/**\n * @template R, T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction fromRef(ref, scheduler) {\n  return _fromRef(ref, scheduler);\n}\n/**\n * @template T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction fromDocRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(startWith(undefined), pairwise(), map(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        priorPayload = _ref2[0],\n        payload = _ref2[1];\n\n    if (!payload.exists) {\n      return {\n        payload: payload,\n        type: 'removed'\n      };\n    }\n\n    if (!(priorPayload === null || priorPayload === void 0 ? void 0 : priorPayload.exists)) {\n      return {\n        payload: payload,\n        type: 'added'\n      };\n    }\n\n    return {\n      payload: payload,\n      type: 'modified'\n    };\n  }));\n}\n/**\n * @template T\n * @param {?} ref\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction fromCollectionRef(ref, scheduler) {\n  return fromRef(ref, scheduler).pipe(map(\n  /**\n  * @param {?} payload\n  * @return {?}\n  */\n\n  /**\n  * @param {?} payload\n  * @return {?}\n  */\n  function (payload) {\n    return {\n      payload: payload,\n      type: 'query'\n    };\n  }));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: collection/changes.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @template T\n * @param {?} query\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction docChanges(query, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(startWith(undefined), pairwise(), map(\n  /**\n  * @param {?} __0\n  * @return {?}\n  */\n  function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        priorAction = _ref4[0],\n        action = _ref4[1];\n\n    /** @type {?} */\n    var docChanges = action.payload.docChanges();\n    /** @type {?} */\n\n    var actions = docChanges.map(\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n\n    /**\n    * @param {?} change\n    * @return {?}\n    */\n    function (change) {\n      return {\n        type: change.type,\n        payload: change\n      };\n    }); // the metadata has changed from the prior emission\n\n    if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n      // go through all the docs in payload and figure out which ones changed\n      action.payload.docs.forEach(\n      /**\n      * @param {?} currentDoc\n      * @param {?} currentIndex\n      * @return {?}\n      */\n      function (currentDoc, currentIndex) {\n        /** @type {?} */\n        var docChange = docChanges.find(\n        /**\n        * @param {?} d\n        * @return {?}\n        */\n\n        /**\n        * @param {?} d\n        * @return {?}\n        */\n        function (d) {\n          return d.doc.ref.isEqual(currentDoc.ref);\n        });\n        /** @type {?} */\n\n        var priorDoc = priorAction === null || priorAction === void 0 ? void 0 : priorAction.payload.docs.find(\n        /**\n        * @param {?} d\n        * @return {?}\n        */\n\n        /**\n        * @param {?} d\n        * @return {?}\n        */\n        function (d) {\n          return d.ref.isEqual(currentDoc.ref);\n        });\n\n        if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) || !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {// document doesn't appear to have changed, don't log another action\n        } else {\n          // since the actions are processed in order just push onto the array\n          actions.push({\n            type: 'modified',\n            payload: {\n              oldIndex: currentIndex,\n              newIndex: currentIndex,\n              type: 'modified',\n              doc: currentDoc\n            }\n          });\n        }\n      });\n    }\n\n    return (\n      /** @type {?} */\n      actions\n    );\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @template T\n * @param {?} query\n * @param {?} events\n * @param {?=} scheduler\n * @return {?}\n */\n\n\nfunction sortedChanges(query, events, scheduler) {\n  return docChanges(query, scheduler).pipe(scan(\n  /**\n  * @param {?} current\n  * @param {?} changes\n  * @return {?}\n  */\n  function (current, changes) {\n    return combineChanges(current, changes.map(\n    /**\n    * @param {?} it\n    * @return {?}\n    */\n\n    /**\n    * @param {?} it\n    * @return {?}\n    */\n    function (it) {\n      return it.payload;\n    }), events);\n  }, []), distinctUntilChanged(), // cut down on unneed change cycles\n  map(\n  /**\n  * @param {?} changes\n  * @return {?}\n  */\n\n  /**\n  * @param {?} changes\n  * @return {?}\n  */\n  function (changes) {\n    return changes.map(\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n\n    /**\n    * @param {?} c\n    * @return {?}\n    */\n    function (c) {\n      return (\n        /** @type {?} */\n        {\n          type: c.type,\n          payload: c\n        }\n      );\n    });\n  }));\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @template T\n * @param {?} current\n * @param {?} changes\n * @param {?} events\n * @return {?}\n */\n\n\nfunction combineChanges(current, changes, events) {\n  changes.forEach(\n  /**\n  * @param {?} change\n  * @return {?}\n  */\n\n  /**\n  * @param {?} change\n  * @return {?}\n  */\n  function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n * @template T\n * @param {?} original\n * @param {?} start\n * @param {?} deleteCount\n * @param {...?} args\n * @return {?}\n */\n\n\nfunction sliceAndSplice(original, start, deleteCount) {\n  /** @type {?} */\n  var returnArray = original.slice();\n\n  for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  returnArray.splice.apply(returnArray, [start, deleteCount].concat(args));\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n * @template T\n * @param {?} combined\n * @param {?} change\n * @return {?}\n */\n\n\nfunction combineChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {// Not sure why the duplicates are getting fired\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          /** @type {?} */\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: collection/collection.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?=} events\n * @return {?}\n */\n\n\nfunction validateEventsArray(events) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n\n  return events;\n}\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n * @template T\n */\n\n\nvar AngularFirestoreCollection = /*#__PURE__*/function () {\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   * @param {?} ref\n   * @param {?} query\n   * @param {?} afs\n   */\n  function AngularFirestoreCollection(ref, query, afs) {\n    _classCallCheck(this, AngularFirestoreCollection);\n\n    this.ref = ref;\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  _createClass(AngularFirestoreCollection, [{\n    key: \"stateChanges\",\n    value: function stateChanges(events) {\n      /** @type {?} */\n      var source = docChanges(this.query, this.afs.schedulers.outsideAngular);\n\n      if (events && events.length > 0) {\n        source = source.pipe(map(\n        /**\n        * @param {?} actions\n        * @return {?}\n        */\n\n        /**\n        * @param {?} actions\n        * @return {?}\n        */\n        function (actions) {\n          return actions.filter(\n          /**\n          * @param {?} change\n          * @return {?}\n          */\n\n          /**\n          * @param {?} change\n          * @return {?}\n          */\n          function (change) {\n            return events.indexOf(change.type) > -1;\n          });\n        }));\n      }\n\n      return source.pipe( // We want to filter out empty arrays, but always emit at first, so the developer knows\n      // that the collection has been resolve; even if it's empty\n      startWith(undefined), pairwise(), filter(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            prior = _ref6[0],\n            current = _ref6[1];\n\n        return current.length > 0 || !prior;\n      }), map(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            prior = _ref8[0],\n            current = _ref8[1];\n\n        return current;\n      }), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     * @param {?=} events\n     * @return {?}\n     */\n\n  }, {\n    key: \"auditTrail\",\n    value: function auditTrail(events) {\n      return this.stateChanges(events).pipe(scan(\n      /**\n      * @param {?} current\n      * @param {?} action\n      * @return {?}\n      */\n      function (current, action) {\n        return [].concat(_toConsumableArray(current), _toConsumableArray(action));\n      }, []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     * @param {?=} events\n     * @return {?}\n     */\n\n  }, {\n    key: \"snapshotChanges\",\n    value: function snapshotChanges(events) {\n      /** @type {?} */\n      var validatedEvents = validateEventsArray(events);\n      /** @type {?} */\n\n      var scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n      return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * @template K\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"valueChanges\",\n    value: function valueChanges() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return fromCollectionRef(this.query, this.afs.schedulers.outsideAngular).pipe(map(\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n      function (actions) {\n        return actions.payload.docs.map(\n        /**\n        * @param {?} a\n        * @return {?}\n        */\n\n        /**\n        * @param {?} a\n        * @return {?}\n        */\n        function (a) {\n          if (options.idField) {\n            return (\n              /** @type {?} */\n              Object.assign(Object.assign({},\n              /** @type {?} */\n              a.data()), _defineProperty({}, options.idField, a.id))\n            );\n          } else {\n            return a.data();\n          }\n        });\n      }), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(options) {\n      return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n    /**\n     * Add data to a collection reference.\n     *\n     * Note: Data operation methods are done on the reference not the query. This means\n     * when you update data it is not updating data to the window of your query unless\n     * the data fits the criteria of the query.\n     * @param {?} data\n     * @return {?}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      return this.ref.add(data);\n    }\n    /**\n     * Create a reference to a single document in a collection.\n     * @template T2\n     * @param {?=} path\n     * @return {?}\n     */\n\n  }, {\n    key: \"doc\",\n    value: function doc(path) {\n      // TODO is there a better way to solve this type issue\n      return new AngularFirestoreDocument(\n      /** @type {?} */\n      this.ref.doc(path), this.afs);\n    }\n  }]);\n\n  return AngularFirestoreCollection;\n}();\n\nif (false) {\n  /** @type {?} */\n  AngularFirestoreCollection.prototype.ref;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreCollection.prototype.query;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreCollection.prototype.afs;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: document/document.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n * @template T\n */\n\n\nvar AngularFirestoreDocument = /*#__PURE__*/function () {\n  /**\n   * The constructor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   * @param {?} ref\n   * @param {?} afs\n   */\n  function AngularFirestoreDocument(ref, afs) {\n    _classCallCheck(this, AngularFirestoreDocument);\n\n    this.ref = ref;\n    this.afs = afs;\n  }\n  /**\n   * Create or overwrite a single document.\n   * @param {?} data\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  _createClass(AngularFirestoreDocument, [{\n    key: \"set\",\n    value: function set(data, options) {\n      return this.ref.set(data, options);\n    }\n    /**\n     * Update some fields of a document without overwriting the entire document.\n     * @param {?} data\n     * @return {?}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(data) {\n      return this.ref.update(data);\n    }\n    /**\n     * Delete a document.\n     * @return {?}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      return this.ref.delete();\n    }\n    /**\n     * Create a reference to a sub-collection given a path and an optional query\n     * function.\n     * @template R\n     * @param {?} path\n     * @param {?=} queryFn\n     * @return {?}\n     */\n\n  }, {\n    key: \"collection\",\n    value: function collection(path, queryFn) {\n      /** @type {?} */\n      var collectionRef =\n      /** @type {?} */\n      this.ref.collection(path);\n\n      var _associateQuery = associateQuery(collectionRef, queryFn),\n          ref = _associateQuery.ref,\n          query = _associateQuery.query;\n\n      return new AngularFirestoreCollection(ref, query, this.afs);\n    }\n    /**\n     * Listen to snapshot updates from the document.\n     * @return {?}\n     */\n\n  }, {\n    key: \"snapshotChanges\",\n    value: function snapshotChanges() {\n      /** @type {?} */\n      var scheduledFromDocRef$ = fromDocRef(this.ref, this.afs.schedulers.outsideAngular);\n      return scheduledFromDocRef$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * @template K\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"valueChanges\",\n    value: function valueChanges() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.snapshotChanges().pipe(map(\n      /**\n      * @param {?} __0\n      * @return {?}\n      */\n      function (_ref9) {\n        var payload = _ref9.payload;\n        return options.idField ?\n        /** @type {?} */\n        Object.assign(Object.assign({}, payload.data()), _defineProperty({}, options.idField, payload.id)) : payload.data();\n      }));\n    }\n    /**\n     * Retrieve the document once.\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(options) {\n      return from(this.ref.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n  }]);\n\n  return AngularFirestoreDocument;\n}();\n\nif (false) {\n  /** @type {?} */\n  AngularFirestoreDocument.prototype.ref;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreDocument.prototype.afs;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: collection-group/collection-group.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n * @template T\n */\n\n\nvar AngularFirestoreCollectionGroup = /*#__PURE__*/function () {\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   * @param {?} query\n   * @param {?} afs\n   */\n  function AngularFirestoreCollectionGroup(query, afs) {\n    _classCallCheck(this, AngularFirestoreCollectionGroup);\n\n    this.query = query;\n    this.afs = afs;\n  }\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   * @param {?=} events\n   * @return {?}\n   */\n\n\n  _createClass(AngularFirestoreCollectionGroup, [{\n    key: \"stateChanges\",\n    value: function stateChanges(events) {\n      if (!events || events.length === 0) {\n        return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(this.afs.keepUnstableUntilFirst);\n      }\n\n      return docChanges(this.query, this.afs.schedulers.outsideAngular).pipe(map(\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n      function (actions) {\n        return actions.filter(\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        function (change) {\n          return events.indexOf(change.type) > -1;\n        });\n      }), filter(\n      /**\n      * @param {?} changes\n      * @return {?}\n      */\n\n      /**\n      * @param {?} changes\n      * @return {?}\n      */\n      function (changes) {\n        return changes.length > 0;\n      }), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n     * but it collects each event in an array over time.\n     * @param {?=} events\n     * @return {?}\n     */\n\n  }, {\n    key: \"auditTrail\",\n    value: function auditTrail(events) {\n      return this.stateChanges(events).pipe(scan(\n      /**\n      * @param {?} current\n      * @param {?} action\n      * @return {?}\n      */\n      function (current, action) {\n        return [].concat(_toConsumableArray(current), _toConsumableArray(action));\n      }, []));\n    }\n    /**\n     * Create a stream of synchronized changes. This method keeps the local array in sorted\n     * query order.\n     * @param {?=} events\n     * @return {?}\n     */\n\n  }, {\n    key: \"snapshotChanges\",\n    value: function snapshotChanges(events) {\n      /** @type {?} */\n      var validatedEvents = validateEventsArray(events);\n      /** @type {?} */\n\n      var scheduledSortedChanges$ = sortedChanges(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n      return scheduledSortedChanges$.pipe(this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * @template K\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"valueChanges\",\n    value: function valueChanges() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      /** @type {?} */\n      var fromCollectionRefScheduled$ = fromCollectionRef(this.query, this.afs.schedulers.outsideAngular);\n      return fromCollectionRefScheduled$.pipe(map(\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n\n      /**\n      * @param {?} actions\n      * @return {?}\n      */\n      function (actions) {\n        return actions.payload.docs.map(\n        /**\n        * @param {?} a\n        * @return {?}\n        */\n\n        /**\n        * @param {?} a\n        * @return {?}\n        */\n        function (a) {\n          if (options.idField) {\n            return (\n              /** @type {?} */\n              Object.assign(_defineProperty({}, options.idField, a.id), a.data())\n            );\n          } else {\n            return a.data();\n          }\n        });\n      }), this.afs.keepUnstableUntilFirst);\n    }\n    /**\n     * Retrieve the results of the query once.\n     * @param {?=} options\n     * @return {?}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(options) {\n      return from(this.query.get(options)).pipe(observeOn(this.afs.schedulers.insideAngular));\n    }\n  }]);\n\n  return AngularFirestoreCollectionGroup;\n}();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  AngularFirestoreCollectionGroup.prototype.query;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AngularFirestoreCollectionGroup.prototype.afs;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: firestore.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n * @type {?}\n */\n\n\nvar ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');\n/** @type {?} */\n\nvar PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');\n/** @type {?} */\n\nvar SETTINGS = new InjectionToken('angularfire2.firestore.settings');\n/** @type {?} */\n\nvar USE_EMULATOR = new InjectionToken('angularfire2.firestore.use-emulator');\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @template T\n * @param {?} collectionRef - A collection reference to query\n * @param {?=} queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n * @return {?}\n */\n\nfunction associateQuery(collectionRef) {\n  var queryFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :\n  /**\n  * @param {?} ref\n  * @return {?}\n  */\n\n  /**\n  * @param {?} ref\n  * @return {?}\n  */\n  function (ref) {\n    return ref;\n  };\n\n  /** @type {?} */\n  var query = queryFn(collectionRef);\n  /** @type {?} */\n\n  var ref = collectionRef;\n  return {\n    query: query,\n    ref: ref\n  };\n}\n\nvar AngularFirestore = /*@__PURE__*/function () {\n  var AngularFirestore = /*#__PURE__*/function () {\n    /**\n     * Each Feature of AngularFire has a FirebaseApp injected. This way we\n     * don't rely on the main Firebase App instance and we can create named\n     * apps and use multiple apps.\n     * @param {?} options\n     * @param {?} nameOrConfig\n     * @param {?} shouldEnablePersistence\n     * @param {?} settings\n     * @param {?} platformId\n     * @param {?} zone\n     * @param {?} persistenceSettings\n     * @param {?} _useEmulator\n     * @param {?} useAuthEmulator\n     */\n    function AngularFirestore(options, nameOrConfig, shouldEnablePersistence, settings, // tslint:disable-next-line:ban-types\n    platformId, zone, persistenceSettings, _useEmulator, useAuthEmulator) {\n      _classCallCheck(this, AngularFirestore);\n\n      this.schedulers = new ɵAngularFireSchedulers(zone);\n      this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers);\n      /** @type {?} */\n\n      var app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n\n      if (!firebase.auth && useAuthEmulator) {\n        ɵlogAuthEmulatorError();\n      }\n      /** @type {?} */\n\n\n      var useEmulator = _useEmulator;\n\n      var _ɵfetchInstance = ɵfetchInstance(\"\".concat(app.name, \".firestore\"), 'AngularFirestore', app,\n      /**\n      * @return {?}\n      */\n      function () {\n        /** @type {?} */\n        var firestore = zone.runOutsideAngular(\n        /**\n        * @return {?}\n        */\n        function () {\n          return app.firestore();\n        });\n\n        if (settings) {\n          firestore.settings(settings);\n        }\n\n        if (useEmulator) {\n          firestore.useEmulator.apply(firestore, _toConsumableArray(useEmulator));\n        }\n\n        if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n          // We need to try/catch here because not all enablePersistence() failures are caught\n          // https://github.com/firebase/firebase-js-sdk/issues/608\n\n          /** @type {?} */\n          var enablePersistence =\n          /**\n          * @return {?}\n          */\n          function enablePersistence() {\n            try {\n              return from(firestore.enablePersistence(persistenceSettings || undefined).then(\n              /**\n              * @return {?}\n              */\n              function () {\n                return true;\n              },\n              /**\n              * @return {?}\n              */\n              function () {\n                return false;\n              }));\n            } catch (e) {\n              if (typeof console !== 'undefined') {\n                console.warn(e);\n              }\n\n              return of(false);\n            }\n          };\n\n          return [firestore, zone.runOutsideAngular(enablePersistence)];\n        } else {\n          return [firestore, of(false)];\n        }\n      }, [settings, useEmulator, shouldEnablePersistence]);\n\n      var _ɵfetchInstance2 = _slicedToArray(_ɵfetchInstance, 2);\n\n      this.firestore = _ɵfetchInstance2[0];\n      this.persistenceEnabled$ = _ɵfetchInstance2[1];\n    }\n    /**\n     * @template T\n     * @param {?} pathOrRef\n     * @param {?=} queryFn\n     * @return {?}\n     */\n\n\n    _createClass(AngularFirestore, [{\n      key: \"collection\",\n      value: function collection(pathOrRef, queryFn) {\n        /** @type {?} */\n        var collectionRef;\n\n        if (typeof pathOrRef === 'string') {\n          collectionRef =\n          /** @type {?} */\n          this.firestore.collection(pathOrRef);\n        } else {\n          collectionRef = pathOrRef;\n        }\n\n        var _associateQuery2 = associateQuery(collectionRef, queryFn),\n            ref = _associateQuery2.ref,\n            query = _associateQuery2.query;\n        /** @type {?} */\n\n\n        var refInZone = this.schedulers.ngZone.run(\n        /**\n        * @return {?}\n        */\n        function () {\n          return ref;\n        });\n        return new AngularFirestoreCollection(refInZone, query, this);\n      }\n      /**\n       * Create a reference to a Firestore Collection Group based on a collectionId\n       * and an optional query function to narrow the result\n       * set.\n       * @template T\n       * @param {?} collectionId\n       * @param {?=} queryGroupFn\n       * @return {?}\n       */\n\n    }, {\n      key: \"collectionGroup\",\n      value: function collectionGroup(collectionId, queryGroupFn) {\n        /** @type {?} */\n        var queryFn = queryGroupFn ||\n        /**\n        * @param {?} ref\n        * @return {?}\n        */\n\n        /**\n        * @param {?} ref\n        * @return {?}\n        */\n        function (ref) {\n          return ref;\n        };\n        /** @type {?} */\n\n\n        var collectionGroup =\n        /** @type {?} */\n        this.firestore.collectionGroup(collectionId);\n        return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);\n      }\n      /**\n       * @template T\n       * @param {?} pathOrRef\n       * @return {?}\n       */\n\n    }, {\n      key: \"doc\",\n      value: function doc(pathOrRef) {\n        /** @type {?} */\n        var ref;\n\n        if (typeof pathOrRef === 'string') {\n          ref =\n          /** @type {?} */\n          this.firestore.doc(pathOrRef);\n        } else {\n          ref = pathOrRef;\n        }\n        /** @type {?} */\n\n\n        var refInZone = this.schedulers.ngZone.run(\n        /**\n        * @return {?}\n        */\n        function () {\n          return ref;\n        });\n        return new AngularFirestoreDocument(refInZone, this);\n      }\n      /**\n       * Returns a generated Firestore Document Id.\n       * @return {?}\n       */\n\n    }, {\n      key: \"createId\",\n      value: function createId() {\n        return this.firestore.collection('_').doc().id;\n      }\n    }]);\n\n    return AngularFirestore;\n  }();\n\n  AngularFirestore.ɵfac = function AngularFirestore_Factory(t) {\n    return new (t || AngularFirestore)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(ENABLE_PERSISTENCE, 8), ɵngcc0.ɵɵinject(SETTINGS, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PERSISTENCE_SETTINGS, 8), ɵngcc0.ɵɵinject(USE_EMULATOR, 8), ɵngcc0.ɵɵinject(USE_EMULATOR$1, 8));\n  };\n  /** @nocollapse */\n\n\n  AngularFirestore.ɵprov = ɵɵdefineInjectable({\n    factory: function AngularFirestore_Factory() {\n      return new AngularFirestore(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(ENABLE_PERSISTENCE, 8), ɵɵinject(SETTINGS, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone), ɵɵinject(PERSISTENCE_SETTINGS, 8), ɵɵinject(USE_EMULATOR, 8), ɵɵinject(USE_EMULATOR$1, 8));\n    },\n    token: AngularFirestore,\n    providedIn: \"any\"\n  });\n  return AngularFirestore;\n}();\n\nif (false) {\n  /** @type {?} */\n  AngularFirestore.prototype.firestore;\n  /** @type {?} */\n\n  AngularFirestore.prototype.persistenceEnabled$;\n  /** @type {?} */\n\n  AngularFirestore.prototype.schedulers;\n  /** @type {?} */\n\n  AngularFirestore.prototype.keepUnstableUntilFirst;\n}\n\nvar AngularFirestoreModule = /*@__PURE__*/function () {\n  var AngularFirestoreModule = /*#__PURE__*/function () {\n    function AngularFirestoreModule() {\n      _classCallCheck(this, AngularFirestoreModule);\n    }\n\n    _createClass(AngularFirestoreModule, null, [{\n      key: \"enablePersistence\",\n      value:\n      /**\n       * Attempt to enable persistent storage, if possible\n       * @param {?=} persistenceSettings\n       * @return {?}\n       */\n      function enablePersistence(persistenceSettings) {\n        return {\n          ngModule: AngularFirestoreModule,\n          providers: [{\n            provide: ENABLE_PERSISTENCE,\n            useValue: true\n          }, {\n            provide: PERSISTENCE_SETTINGS,\n            useValue: persistenceSettings\n          }]\n        };\n      }\n    }]);\n\n    return AngularFirestoreModule;\n  }();\n\n  AngularFirestoreModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFirestoreModule\n  });\n  AngularFirestoreModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function AngularFirestoreModule_Factory(t) {\n      return new (t || AngularFirestoreModule)();\n    },\n    providers: [AngularFirestore]\n  });\n  return AngularFirestoreModule;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: interfaces.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n * @template T\n */\n\n\nfunction DocumentSnapshotExists() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentSnapshotExists.prototype.exists;\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n\n  DocumentSnapshotExists.prototype.data = function (options) {};\n}\n/**\n * @record\n */\n\n\nfunction DocumentSnapshotDoesNotExist() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentSnapshotDoesNotExist.prototype.exists;\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n\n  DocumentSnapshotDoesNotExist.prototype.data = function (options) {};\n  /**\n   * @param {?} fieldPath\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  DocumentSnapshotDoesNotExist.prototype.get = function (fieldPath, options) {};\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction QueryDocumentSnapshot() {}\n\nif (false) {\n  /**\n   * @param {?=} options\n   * @return {?}\n   */\n  QueryDocumentSnapshot.prototype.data = function (options) {};\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction QuerySnapshot() {}\n\nif (false) {\n  /** @type {?} */\n  QuerySnapshot.prototype.docs;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction DocumentChange() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentChange.prototype.doc;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction DocumentChangeAction() {}\n\nif (false) {\n  /** @type {?} */\n  DocumentChangeAction.prototype.type;\n  /** @type {?} */\n\n  DocumentChangeAction.prototype.payload;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction Action() {}\n\nif (false) {\n  /** @type {?} */\n  Action.prototype.type;\n  /** @type {?} */\n\n  Action.prototype.payload;\n}\n/**\n * @record\n * @template T\n */\n\n\nfunction Reference() {}\n\nif (false) {\n  /** @type {?} */\n  Reference.prototype.onSnapshot;\n}\n/**\n * A structure that provides an association between a reference\n * and a query on that reference. Note: Performing operations\n * on the reference can lead to confusing results with complicated\n * queries.\n *\n * Example:\n *\n * const query = ref.where('type', '==', 'Book').\n *                  .where('price', '>' 18.00)\n *                  .where('price', '<' 100.00)\n *                  .where('category', '==', 'Fiction')\n *                  .where('publisher', '==', 'BigPublisher')\n *\n * // This addition would not be a result of the query above\n * ref.add({\n *  type: 'Magazine',\n *  price: 4.99,\n *  category: 'Sports',\n *  publisher: 'SportsPublisher'\n * });\n * @record\n * @template T\n */\n\n\nfunction AssociatedReference() {}\n\nif (false) {\n  /** @type {?} */\n  AssociatedReference.prototype.ref;\n  /** @type {?} */\n\n  AssociatedReference.prototype.query;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire-firestore.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFirestore, AngularFirestoreCollection, AngularFirestoreCollectionGroup, AngularFirestoreDocument, AngularFirestoreModule, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS, SETTINGS, USE_EMULATOR, associateQuery, combineChange, combineChanges, docChanges, fromCollectionRef, fromDocRef, fromRef, sortedChanges, validateEventsArray };","map":null,"metadata":{},"sourceType":"module"}