{"ast":null,"code":"import _createForOfIteratorHelper from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _inherits from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createClass from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport { APP_BOOTSTRAP_LISTENER, PLATFORM_ID, NgModule, Injectable, InjectionToken, Inject, inject, NgZone, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';\nimport { DOCUMENT, isPlatformBrowser, isPlatformServer } from '@angular/common';\nimport { Subject, BehaviorSubject, Observable, merge, asapScheduler, of, fromEvent } from 'rxjs';\nimport { filter, debounceTime, map, switchMap, takeUntil, take, tap } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * Generated from: core/browser-provider.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Find all of the server-generated stylings, if any, and remove them\n * This will be in the form of inline classes and the style block in the\n * head of the DOM\n * @param {?} _document\n * @param {?} platformId\n * @return {?}\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nfunction removeStyles(_document, platformId) {\n  return (\n    /**\n    * @return {?}\n    */\n    function () {\n      if (isPlatformBrowser(platformId)) {\n        /** @type {?} */\n        var elements = Array.from(_document.querySelectorAll(\"[class*=\".concat(CLASS_NAME, \"]\"))); // RegExp constructor should only be used if passing a variable to the constructor.\n        // When using static regular expression it is more performant to use reg exp literal.\n        // This is also needed to provide Safari 9 compatibility, please see\n        // https://stackoverflow.com/questions/37919802 for more discussion.\n\n        /** @type {?} */\n\n        var classRegex = /\\bflex-layout-.+?\\b/g;\n        elements.forEach(\n        /**\n        * @param {?} el\n        * @return {?}\n        */\n\n        /**\n        * @param {?} el\n        * @return {?}\n        */\n        function (el) {\n          el.classList.contains(\"\".concat(CLASS_NAME, \"ssr\")) && el.parentNode ? el.parentNode.removeChild(el) : el.className.replace(classRegex, '');\n        });\n      }\n    }\n  );\n}\n/**\n *  Provider to remove SSR styles on the browser\n * @type {?}\n */\n\n\nvar BROWSER_PROVIDER = {\n  provide:\n  /** @type {?} */\n  APP_BOOTSTRAP_LISTENER,\n  useFactory: removeStyles,\n  deps: [DOCUMENT, PLATFORM_ID],\n  multi: true\n};\n/** @type {?} */\n\nvar CLASS_NAME = 'flex-layout-';\n\nvar CoreModule = /*@__PURE__*/function () {\n  var CoreModule = function CoreModule() {\n    _classCallCheck(this, CoreModule);\n  };\n\n  CoreModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: CoreModule\n  });\n  CoreModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function CoreModule_Factory(t) {\n      return new (t || CoreModule)();\n    },\n    providers: [BROWSER_PROVIDER]\n  });\n  return CoreModule;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-change.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Class instances emitted [to observers] for each mql notification\n */\n\n\nvar MediaChange = /*#__PURE__*/function () {\n  /**\n   * @param {?=} matches whether the mediaQuery is currently activated\n   * @param {?=} mediaQuery e.g. (min-width: 600px) and (max-width: 959px)\n   * @param {?=} mqAlias e.g. gt-sm, md, gt-lg\n   * @param {?=} suffix e.g. GtSM, Md, GtLg\n   * @param {?=} priority the priority of activation for the given breakpoint\n   */\n  function MediaChange() {\n    var matches = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var mediaQuery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';\n    var mqAlias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    var priority = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n    _classCallCheck(this, MediaChange);\n\n    this.matches = matches;\n    this.mediaQuery = mediaQuery;\n    this.mqAlias = mqAlias;\n    this.suffix = suffix;\n    this.priority = priority;\n    this.property = '';\n  }\n  /**\n   * Create an exact copy of the MediaChange\n   * @return {?}\n   */\n\n\n  _createClass(MediaChange, [{\n    key: \"clone\",\n    value: function clone() {\n      return new MediaChange(this.matches, this.mediaQuery, this.mqAlias, this.suffix);\n    }\n  }]);\n\n  return MediaChange;\n}();\n\nvar StylesheetMap = /*@__PURE__*/function () {\n  var StylesheetMap = /*#__PURE__*/function () {\n    function StylesheetMap() {\n      _classCallCheck(this, StylesheetMap);\n\n      this.stylesheet = new Map();\n    }\n    /**\n     * Add an individual style to an HTML element\n     * @param {?} element\n     * @param {?} style\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    _createClass(StylesheetMap, [{\n      key: \"addStyleToElement\",\n      value: function addStyleToElement(element, style, value) {\n        /** @type {?} */\n        var stylesheet = this.stylesheet.get(element);\n\n        if (stylesheet) {\n          stylesheet.set(style, value);\n        } else {\n          this.stylesheet.set(element, new Map([[style, value]]));\n        }\n      }\n      /**\n       * Clear the virtual stylesheet\n       * @return {?}\n       */\n\n    }, {\n      key: \"clearStyles\",\n      value: function clearStyles() {\n        this.stylesheet.clear();\n      }\n      /**\n       * Retrieve a given style for an HTML element\n       * @param {?} el\n       * @param {?} styleName\n       * @return {?}\n       */\n\n    }, {\n      key: \"getStyleForElement\",\n      value: function getStyleForElement(el, styleName) {\n        /** @type {?} */\n        var styles = this.stylesheet.get(el);\n        /** @type {?} */\n\n        var value = '';\n\n        if (styles) {\n          /** @type {?} */\n          var style = styles.get(styleName);\n\n          if (typeof style === 'number' || typeof style === 'string') {\n            value = style + '';\n          }\n        }\n\n        return value;\n      }\n    }]);\n\n    return StylesheetMap;\n  }();\n\n  StylesheetMap.ɵfac = function StylesheetMap_Factory(t) {\n    return new (t || StylesheetMap)();\n  };\n  /** @nocollapse */\n\n\n  StylesheetMap.ɵprov = ɵɵdefineInjectable({\n    factory: function StylesheetMap_Factory() {\n      return new StylesheetMap();\n    },\n    token: StylesheetMap,\n    providedIn: \"root\"\n  });\n  return StylesheetMap;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/stylesheet-map/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/tokens/library-config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar DEFAULT_CONFIG = {\n  addFlexToParent: true,\n  addOrientationBps: false,\n  disableDefaultBps: false,\n  disableVendorPrefixes: false,\n  serverLoaded: false,\n  useColumnBasisZero: true,\n  printWithBreakpoints: [],\n  mediaTriggerAutoRestore: true,\n  ssrObserveBreakpoints: []\n};\n/** @type {?} */\n\nvar LAYOUT_CONFIG = new InjectionToken('Flex Layout token, config options for the library', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  function factory() {\n    return DEFAULT_CONFIG;\n  }\n});\n/**\n * @fileoverview added by tsickle\n * Generated from: core/tokens/server-token.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Token that is provided to tell whether the FlexLayoutServerModule\n * has been included in the bundle\n *\n * NOTE: This can be manually provided to disable styles when using SSR\n * @type {?}\n */\n\nvar SERVER_TOKEN = new InjectionToken('FlexLayoutServerLoaded', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  function factory() {\n    return false;\n  }\n});\n/**\n * @fileoverview added by tsickle\n * Generated from: core/tokens/breakpoint-token.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nvar BREAKPOINT = new InjectionToken('Flex Layout token, collect all breakpoints into one provider', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  function factory() {\n    return null;\n  }\n});\n/**\n * @fileoverview added by tsickle\n * Generated from: core/tokens/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/add-alias.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * For the specified MediaChange, make sure it contains the breakpoint alias\n * and suffix (if available).\n * @param {?} dest\n * @param {?} source\n * @return {?}\n */\n\nfunction mergeAlias(dest, source) {\n  dest = dest ? dest.clone() : new MediaChange();\n\n  if (source) {\n    dest.mqAlias = source.alias;\n    dest.mediaQuery = source.mediaQuery;\n    dest.suffix =\n    /** @type {?} */\n    source.suffix;\n    dest.priority =\n    /** @type {?} */\n    source.priority;\n  }\n\n  return dest;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: utils/layout-validator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n * @type {?}\n */\n\n\nvar INLINE = 'inline';\n/** @type {?} */\n\nvar LAYOUT_VALUES = ['row', 'column', 'row-reverse', 'column-reverse'];\n/**\n * Validate the direction|'direction wrap' value and then update the host's inline flexbox styles\n * @param {?} value\n * @return {?}\n */\n\nfunction buildLayoutCSS(value) {\n  var _validateValue = validateValue(value),\n      _validateValue2 = _slicedToArray(_validateValue, 3),\n      direction = _validateValue2[0],\n      wrap = _validateValue2[1],\n      isInline = _validateValue2[2];\n\n  return buildCSS(direction, wrap, isInline);\n}\n/**\n * Validate the value to be one of the acceptable value options\n * Use default fallback of 'row'\n * @param {?} value\n * @return {?}\n */\n\n\nfunction validateValue(value) {\n  value = value ? value.toLowerCase() : '';\n\n  var _value$split = value.split(' '),\n      _value$split2 = _slicedToArray(_value$split, 3),\n      direction = _value$split2[0],\n      wrap = _value$split2[1],\n      inline = _value$split2[2]; // First value must be the `flex-direction`\n\n\n  if (!LAYOUT_VALUES.find(\n  /**\n  * @param {?} x\n  * @return {?}\n  */\n\n  /**\n  * @param {?} x\n  * @return {?}\n  */\n  function (x) {\n    return x === direction;\n  })) {\n    direction = LAYOUT_VALUES[0];\n  }\n\n  if (wrap === INLINE) {\n    wrap = inline !== INLINE ? inline : '';\n    inline = INLINE;\n  }\n\n  return [direction, validateWrapValue(wrap), !!inline];\n}\n/**\n * Convert layout-wrap='<value>' to expected flex-wrap style\n * @param {?} value\n * @return {?}\n */\n\n\nfunction validateWrapValue(value) {\n  if (!!value) {\n    switch (value.toLowerCase()) {\n      case 'reverse':\n      case 'wrap-reverse':\n      case 'reverse-wrap':\n        value = 'wrap-reverse';\n        break;\n\n      case 'no':\n      case 'none':\n      case 'nowrap':\n        value = 'nowrap';\n        break;\n      // All other values fallback to 'wrap'\n\n      default:\n        value = 'wrap';\n        break;\n    }\n  }\n\n  return value;\n}\n/**\n * Build the CSS that should be assigned to the element instance\n * BUG:\n *   1) min-height on a column flex container won’t apply to its flex item children in IE 10-11.\n *      Use height instead if possible; height : <xxx>vh;\n *\n *  This way any padding or border specified on the child elements are\n *  laid out and drawn inside that element's specified width and height.\n * @param {?} direction\n * @param {?=} wrap\n * @param {?=} inline\n * @return {?}\n */\n\n\nfunction buildCSS(direction) {\n  var wrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var inline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return {\n    'display': inline ? 'inline-flex' : 'flex',\n    'box-sizing': 'border-box',\n    'flex-direction': direction,\n    'flex-wrap': !!wrap ? wrap : null\n  };\n}\n\nvar BaseDirective2 = /*@__PURE__*/function () {\n  var BaseDirective2 = /*#__PURE__*/function () {\n    /**\n     * @protected\n     * @param {?} elementRef\n     * @param {?} styleBuilder\n     * @param {?} styler\n     * @param {?} marshal\n     */\n    function BaseDirective2(elementRef, styleBuilder, styler, marshal) {\n      _classCallCheck(this, BaseDirective2);\n\n      this.elementRef = elementRef;\n      this.styleBuilder = styleBuilder;\n      this.styler = styler;\n      this.marshal = marshal;\n      this.DIRECTIVE_KEY = '';\n      this.inputs = [];\n      /**\n       * The most recently used styles for the builder\n       */\n\n      this.mru = {};\n      this.destroySubject = new Subject();\n      /**\n       * Cache map for style computation\n       */\n\n      this.styleCache = new Map();\n    }\n    /**\n     * Access to host element's parent DOM node\n     * @protected\n     * @return {?}\n     */\n\n\n    _createClass(BaseDirective2, [{\n      key: \"parentElement\",\n      get: function get() {\n        return this.elementRef.nativeElement.parentElement;\n      }\n      /**\n       * Access to the HTMLElement for the directive\n       * @protected\n       * @return {?}\n       */\n\n    }, {\n      key: \"nativeElement\",\n      get: function get() {\n        return this.elementRef.nativeElement;\n      }\n      /**\n       * Access to the activated value for the directive\n       * @return {?}\n       */\n\n    }, {\n      key: \"activatedValue\",\n      get: function get() {\n        return this.marshal.getValue(this.nativeElement, this.DIRECTIVE_KEY);\n      }\n      /**\n       * @param {?} value\n       * @return {?}\n       */\n      ,\n      set: function set(value) {\n        this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, value, this.marshal.activatedAlias);\n      }\n      /**\n       * For \\@Input changes\n       * @param {?} changes\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnChanges\",\n      value: function ngOnChanges(changes) {\n        var _this = this;\n\n        Object.keys(changes).forEach(\n        /**\n        * @param {?} key\n        * @return {?}\n        */\n\n        /**\n        * @param {?} key\n        * @return {?}\n        */\n        function (key) {\n          if (_this.inputs.indexOf(key) !== -1) {\n            /** @type {?} */\n            var bp = key.split('.').slice(1).join('.');\n            /** @type {?} */\n\n            var val = changes[key].currentValue;\n\n            _this.setValue(val, bp);\n          }\n        });\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.destroySubject.next();\n        this.destroySubject.complete();\n        this.marshal.releaseElement(this.nativeElement);\n      }\n      /**\n       * Register with central marshaller service\n       * @protected\n       * @param {?=} extraTriggers\n       * @return {?}\n       */\n\n    }, {\n      key: \"init\",\n      value: function init() {\n        var extraTriggers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        this.marshal.init(this.elementRef.nativeElement, this.DIRECTIVE_KEY, this.updateWithValue.bind(this), this.clearStyles.bind(this), extraTriggers);\n      }\n      /**\n       * Add styles to the element using predefined style builder\n       * @protected\n       * @param {?} input\n       * @param {?=} parent\n       * @return {?}\n       */\n\n    }, {\n      key: \"addStyles\",\n      value: function addStyles(input, parent) {\n        /** @type {?} */\n        var builder = this.styleBuilder;\n        /** @type {?} */\n\n        var useCache = builder.shouldCache;\n        /** @type {?} */\n\n        var genStyles = this.styleCache.get(input);\n\n        if (!genStyles || !useCache) {\n          genStyles = builder.buildStyles(input, parent);\n\n          if (useCache) {\n            this.styleCache.set(input, genStyles);\n          }\n        }\n\n        this.mru = Object.assign({}, genStyles);\n        this.applyStyleToElement(genStyles);\n        builder.sideEffect(input, genStyles, parent);\n      }\n      /**\n       * Remove generated styles from an element using predefined style builder\n       * @protected\n       * @return {?}\n       */\n\n    }, {\n      key: \"clearStyles\",\n      value: function clearStyles() {\n        var _this2 = this;\n\n        Object.keys(this.mru).forEach(\n        /**\n        * @param {?} k\n        * @return {?}\n        */\n\n        /**\n        * @param {?} k\n        * @return {?}\n        */\n        function (k) {\n          _this2.mru[k] = '';\n        });\n        this.applyStyleToElement(this.mru);\n        this.mru = {};\n      }\n      /**\n       * Force trigger style updates on DOM element\n       * @protected\n       * @return {?}\n       */\n\n    }, {\n      key: \"triggerUpdate\",\n      value: function triggerUpdate() {\n        this.marshal.triggerUpdate(this.nativeElement, this.DIRECTIVE_KEY);\n      }\n      /**\n       * Determine the DOM element's Flexbox flow (flex-direction).\n       *\n       * Check inline style first then check computed (stylesheet) style.\n       * And optionally add the flow value to element's inline style.\n       * @protected\n       * @param {?} target\n       * @param {?=} addIfMissing\n       * @return {?}\n       */\n\n    }, {\n      key: \"getFlexFlowDirection\",\n      value: function getFlexFlowDirection(target) {\n        var addIfMissing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (target) {\n          var _this$styler$getFlowD = this.styler.getFlowDirection(target),\n              _this$styler$getFlowD2 = _slicedToArray(_this$styler$getFlowD, 2),\n              value = _this$styler$getFlowD2[0],\n              hasInlineValue = _this$styler$getFlowD2[1];\n\n          if (!hasInlineValue && addIfMissing) {\n            /** @type {?} */\n            var style = buildLayoutCSS(value);\n            /** @type {?} */\n\n            var elements = [target];\n            this.styler.applyStyleToElements(style, elements);\n          }\n\n          return value.trim();\n        }\n\n        return 'row';\n      }\n      /**\n       * @protected\n       * @param {?} target\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasWrap\",\n      value: function hasWrap(target) {\n        return this.styler.hasWrap(target);\n      }\n      /**\n       * Applies styles given via string pair or object map to the directive element\n       * @protected\n       * @param {?} style\n       * @param {?=} value\n       * @param {?=} element\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyStyleToElement\",\n      value: function applyStyleToElement(style, value) {\n        var element = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.nativeElement;\n        this.styler.applyStyleToElement(element, style, value);\n      }\n      /**\n       * @protected\n       * @param {?} val\n       * @param {?} bp\n       * @return {?}\n       */\n\n    }, {\n      key: \"setValue\",\n      value: function setValue(val, bp) {\n        this.marshal.setValue(this.nativeElement, this.DIRECTIVE_KEY, val, bp);\n      }\n      /**\n       * @protected\n       * @param {?} input\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateWithValue\",\n      value: function updateWithValue(input) {\n        if (this.currentValue !== input) {\n          this.addStyles(input);\n          this.currentValue = input;\n        }\n      }\n    }]);\n\n    return BaseDirective2;\n  }();\n\n  BaseDirective2.ɵfac = function BaseDirective2_Factory(t) {\n    ɵngcc0.ɵɵinvalidFactory();\n  };\n\n  BaseDirective2.ɵdir = ɵngcc0.ɵɵdefineDirective({\n    type: BaseDirective2,\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  return BaseDirective2;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/base/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/data/break-points.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * NOTE: Smaller ranges have HIGHER priority since the match is more specific\n * @type {?}\n */\n\n\nvar DEFAULT_BREAKPOINTS = [{\n  alias: 'xs',\n  mediaQuery: 'screen and (min-width: 0px) and (max-width: 599.98px)',\n  priority: 1000\n}, {\n  alias: 'sm',\n  mediaQuery: 'screen and (min-width: 600px) and (max-width: 959.98px)',\n  priority: 900\n}, {\n  alias: 'md',\n  mediaQuery: 'screen and (min-width: 960px) and (max-width: 1279.98px)',\n  priority: 800\n}, {\n  alias: 'lg',\n  mediaQuery: 'screen and (min-width: 1280px) and (max-width: 1919.98px)',\n  priority: 700\n}, {\n  alias: 'xl',\n  mediaQuery: 'screen and (min-width: 1920px) and (max-width: 4999.98px)',\n  priority: 600\n}, {\n  alias: 'lt-sm',\n  overlapping: true,\n  mediaQuery: 'screen and (max-width: 599.98px)',\n  priority: 950\n}, {\n  alias: 'lt-md',\n  overlapping: true,\n  mediaQuery: 'screen and (max-width: 959.98px)',\n  priority: 850\n}, {\n  alias: 'lt-lg',\n  overlapping: true,\n  mediaQuery: 'screen and (max-width: 1279.98px)',\n  priority: 750\n}, {\n  alias: 'lt-xl',\n  overlapping: true,\n  priority: 650,\n  mediaQuery: 'screen and (max-width: 1919.98px)'\n}, {\n  alias: 'gt-xs',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 600px)',\n  priority: -950\n}, {\n  alias: 'gt-sm',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 960px)',\n  priority: -850\n}, {\n  alias: 'gt-md',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 1280px)',\n  priority: -750\n}, {\n  alias: 'gt-lg',\n  overlapping: true,\n  mediaQuery: 'screen and (min-width: 1920px)',\n  priority: -650\n}];\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/data/orientation-break-points.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/* tslint:disable */\n\n/** @type {?} */\n\nvar HANDSET_PORTRAIT = '(orientation: portrait) and (max-width: 599.98px)';\n/** @type {?} */\n\nvar HANDSET_LANDSCAPE = '(orientation: landscape) and (max-width: 959.98px)';\n/** @type {?} */\n\nvar TABLET_PORTRAIT = '(orientation: portrait) and (min-width: 600px) and (max-width: 839.98px)';\n/** @type {?} */\n\nvar TABLET_LANDSCAPE = '(orientation: landscape) and (min-width: 960px) and (max-width: 1279.98px)';\n/** @type {?} */\n\nvar WEB_PORTRAIT = '(orientation: portrait) and (min-width: 840px)';\n/** @type {?} */\n\nvar WEB_LANDSCAPE = '(orientation: landscape) and (min-width: 1280px)';\n/** @type {?} */\n\nvar ScreenTypes = {\n  'HANDSET': \"\".concat(HANDSET_PORTRAIT, \", \").concat(HANDSET_LANDSCAPE),\n  'TABLET': \"\".concat(TABLET_PORTRAIT, \" , \").concat(TABLET_LANDSCAPE),\n  'WEB': \"\".concat(WEB_PORTRAIT, \", \").concat(WEB_LANDSCAPE, \" \"),\n  'HANDSET_PORTRAIT': \"\".concat(HANDSET_PORTRAIT),\n  'TABLET_PORTRAIT': \"\".concat(TABLET_PORTRAIT, \" \"),\n  'WEB_PORTRAIT': \"\".concat(WEB_PORTRAIT),\n  'HANDSET_LANDSCAPE': \"\".concat(HANDSET_LANDSCAPE),\n  'TABLET_LANDSCAPE': \"\".concat(TABLET_LANDSCAPE),\n  'WEB_LANDSCAPE': \"\".concat(WEB_LANDSCAPE)\n};\n/**\n * Extended Breakpoints for handset/tablets with landscape or portrait orientations\n * @type {?}\n */\n\nvar ORIENTATION_BREAKPOINTS = [{\n  'alias': 'handset',\n  priority: 2000,\n  'mediaQuery': ScreenTypes.HANDSET\n}, {\n  'alias': 'handset.landscape',\n  priority: 2000,\n  'mediaQuery': ScreenTypes.HANDSET_LANDSCAPE\n}, {\n  'alias': 'handset.portrait',\n  priority: 2000,\n  'mediaQuery': ScreenTypes.HANDSET_PORTRAIT\n}, {\n  'alias': 'tablet',\n  priority: 2100,\n  'mediaQuery': ScreenTypes.TABLET\n}, {\n  'alias': 'tablet.landscape',\n  priority: 2100,\n  'mediaQuery': ScreenTypes.TABLET_LANDSCAPE\n}, {\n  'alias': 'tablet.portrait',\n  priority: 2100,\n  'mediaQuery': ScreenTypes.TABLET_PORTRAIT\n}, {\n  'alias': 'web',\n  priority: 2200,\n  'mediaQuery': ScreenTypes.WEB,\n  overlapping: true\n}, {\n  'alias': 'web.landscape',\n  priority: 2200,\n  'mediaQuery': ScreenTypes.WEB_LANDSCAPE,\n  overlapping: true\n}, {\n  'alias': 'web.portrait',\n  priority: 2200,\n  'mediaQuery': ScreenTypes.WEB_PORTRAIT,\n  overlapping: true\n}];\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/break-point.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: utils/object-extend.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Extends an object with the *enumerable* and *own* properties of one or more source objects,\n * similar to Object.assign.\n *\n * @param {?} dest The object which will have properties copied to it.\n * @param {...?} sources The source objects from which properties will be copied.\n * @return {?}\n */\n\nfunction extendObject(dest) {\n  if (dest == null) {\n    throw TypeError('Cannot convert undefined or null to object');\n  }\n\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n\n  for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {\n    var source = _sources[_i];\n\n    if (source != null) {\n      for (var key in source) {\n        if (source.hasOwnProperty(key)) {\n          dest[key] = source[key];\n        }\n      }\n    }\n  }\n\n  return dest;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/breakpoint-tools.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar ALIAS_DELIMITERS = /(\\.|-|_)/g;\n/**\n * @param {?} part\n * @return {?}\n */\n\nfunction firstUpperCase(part) {\n  /** @type {?} */\n  var first = part.length > 0 ? part.charAt(0) : '';\n  /** @type {?} */\n\n  var remainder = part.length > 1 ? part.slice(1) : '';\n  return first.toUpperCase() + remainder;\n}\n/**\n * Converts snake-case to SnakeCase.\n * @param {?} name Text to UpperCamelCase\n * @return {?}\n */\n\n\nfunction camelCase(name) {\n  return name.replace(ALIAS_DELIMITERS, '|').split('|').map(firstUpperCase).join('');\n}\n/**\n * For each breakpoint, ensure that a Suffix is defined;\n * fallback to UpperCamelCase the unique Alias value\n * @param {?} list\n * @return {?}\n */\n\n\nfunction validateSuffixes(list) {\n  list.forEach(\n  /**\n  * @param {?} bp\n  * @return {?}\n  */\n  function (bp) {\n    if (!bp.suffix) {\n      bp.suffix = camelCase(bp.alias); // create Suffix value based on alias\n\n      bp.overlapping = !!bp.overlapping; // ensure default value\n    }\n  });\n  return list;\n}\n/**\n * Merge a custom breakpoint list with the default list based on unique alias values\n *  - Items are added if the alias is not in the default list\n *  - Items are merged with the custom override if the alias exists in the default list\n * @param {?} defaults\n * @param {?=} custom\n * @return {?}\n */\n\n\nfunction mergeByAlias(defaults) {\n  var custom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  /** @type {?} */\n  var dict = {};\n  defaults.forEach(\n  /**\n  * @param {?} bp\n  * @return {?}\n  */\n\n  /**\n  * @param {?} bp\n  * @return {?}\n  */\n  function (bp) {\n    dict[bp.alias] = bp;\n  }); // Merge custom breakpoints\n\n  custom.forEach(\n  /**\n  * @param {?} bp\n  * @return {?}\n  */\n  function (bp) {\n    if (dict[bp.alias]) {\n      extendObject(dict[bp.alias], bp);\n    } else {\n      dict[bp.alias] = bp;\n    }\n  });\n  return validateSuffixes(Object.keys(dict).map(\n  /**\n  * @param {?} k\n  * @return {?}\n  */\n\n  /**\n  * @param {?} k\n  * @return {?}\n  */\n  function (k) {\n    return dict[k];\n  }));\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: core/breakpoints/break-points-token.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n *  Injection token unique to the flex-layout library.\n *  Use this token when build a custom provider (see below).\n * @type {?}\n */\n\n\nvar BREAKPOINTS = new InjectionToken('Token (@angular/flex-layout) Breakpoints', {\n  providedIn: 'root',\n  factory:\n  /**\n  * @return {?}\n  */\n  function factory() {\n    /** @type {?} */\n    var breakpoints = inject(BREAKPOINT);\n    /** @type {?} */\n\n    var layoutConfig = inject(LAYOUT_CONFIG);\n    /** @type {?} */\n\n    var bpFlattenArray = [].concat.apply([], (breakpoints || []).map(\n    /**\n    * @param {?} v\n    * @return {?}\n    */\n    function (v) {\n      return Array.isArray(v) ? v : [v];\n    }));\n    /** @type {?} */\n\n    var builtIns = (layoutConfig.disableDefaultBps ? [] : DEFAULT_BREAKPOINTS).concat(layoutConfig.addOrientationBps ? ORIENTATION_BREAKPOINTS : []);\n    return mergeByAlias(builtIns, bpFlattenArray);\n  }\n});\n/**\n * @fileoverview added by tsickle\n * Generated from: core/utils/sort.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * HOF to sort the breakpoints by descending priority\n * @template T\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\nfunction sortDescendingPriority(a, b) {\n  /** @type {?} */\n  var priorityA = a ? a.priority || 0 : 0;\n  /** @type {?} */\n\n  var priorityB = b ? b.priority || 0 : 0;\n  return priorityB - priorityA;\n}\n/**\n * HOF to sort the breakpoints by ascending priority\n * @template T\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\n\n\nfunction sortAscendingPriority(a, b) {\n  /** @type {?} */\n  var pA = a.priority || 0;\n  /** @type {?} */\n\n  var pB = b.priority || 0;\n  return pA - pB;\n}\n\nvar BreakPointRegistry = /*@__PURE__*/function () {\n  var BreakPointRegistry = /*#__PURE__*/function () {\n    /**\n     * @param {?} list\n     */\n    function BreakPointRegistry(list) {\n      _classCallCheck(this, BreakPointRegistry);\n\n      /**\n       * Memoized BreakPoint Lookups\n       */\n      this.findByMap = new Map();\n      this.items = _toConsumableArray(list).sort(sortAscendingPriority);\n    }\n    /**\n     * Search breakpoints by alias (e.g. gt-xs)\n     * @param {?} alias\n     * @return {?}\n     */\n\n\n    _createClass(BreakPointRegistry, [{\n      key: \"findByAlias\",\n      value: function findByAlias(alias) {\n        return !alias ? null : this.findWithPredicate(alias,\n        /**\n        * @param {?} bp\n        * @return {?}\n        */\n        function (bp) {\n          return bp.alias == alias;\n        });\n      }\n      /**\n       * @param {?} query\n       * @return {?}\n       */\n\n    }, {\n      key: \"findByQuery\",\n      value: function findByQuery(query) {\n        return this.findWithPredicate(query,\n        /**\n        * @param {?} bp\n        * @return {?}\n        */\n        function (bp) {\n          return bp.mediaQuery == query;\n        });\n      }\n      /**\n       * Get all the breakpoints whose ranges could overlapping `normal` ranges;\n       * e.g. gt-sm overlaps md, lg, and xl\n       * @return {?}\n       */\n\n    }, {\n      key: \"overlappings\",\n      get: function get() {\n        return this.items.filter(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        function (it) {\n          return it.overlapping == true;\n        });\n      }\n      /**\n       * Get list of all registered (non-empty) breakpoint aliases\n       * @return {?}\n       */\n\n    }, {\n      key: \"aliases\",\n      get: function get() {\n        return this.items.map(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        function (it) {\n          return it.alias;\n        });\n      }\n      /**\n       * Aliases are mapped to properties using suffixes\n       * e.g.  'gt-sm' for property 'layout'  uses suffix 'GtSm'\n       * for property layoutGtSM.\n       * @return {?}\n       */\n\n    }, {\n      key: \"suffixes\",\n      get: function get() {\n        return this.items.map(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        function (it) {\n          return !!it.suffix ? it.suffix : '';\n        });\n      }\n      /**\n       * Memoized lookup using custom predicate function\n       * @private\n       * @param {?} key\n       * @param {?} searchFn\n       * @return {?}\n       */\n\n    }, {\n      key: \"findWithPredicate\",\n      value: function findWithPredicate(key, searchFn) {\n        /** @type {?} */\n        var response = this.findByMap.get(key);\n\n        if (!response) {\n          response = this.items.find(searchFn) || null;\n          this.findByMap.set(key, response);\n        }\n\n        return response || null;\n      }\n    }]);\n\n    return BreakPointRegistry;\n  }();\n\n  BreakPointRegistry.ɵfac = function BreakPointRegistry_Factory(t) {\n    return new (t || BreakPointRegistry)(ɵngcc0.ɵɵinject(BREAKPOINTS));\n  };\n  /** @nocollapse */\n\n\n  BreakPointRegistry.ɵprov = ɵɵdefineInjectable({\n    factory: function BreakPointRegistry_Factory() {\n      return new BreakPointRegistry(ɵɵinject(BREAKPOINTS));\n    },\n    token: BreakPointRegistry,\n    providedIn: \"root\"\n  });\n  return BreakPointRegistry;\n}();\n\nvar MatchMedia = /*@__PURE__*/function () {\n  var MatchMedia = /*#__PURE__*/function () {\n    /**\n     * @param {?} _zone\n     * @param {?} _platformId\n     * @param {?} _document\n     */\n    function MatchMedia(_zone, _platformId, _document) {\n      _classCallCheck(this, MatchMedia);\n\n      this._zone = _zone;\n      this._platformId = _platformId;\n      this._document = _document;\n      /**\n       * Initialize source with 'all' so all non-responsive APIs trigger style updates\n       */\n\n      this.source = new BehaviorSubject(new MediaChange(true));\n      this.registry = new Map();\n      this.pendingRemoveListenerFns = [];\n      this._observable$ = this.source.asObservable();\n    }\n    /**\n     * Publish list of all current activations\n     * @return {?}\n     */\n\n\n    _createClass(MatchMedia, [{\n      key: \"activations\",\n      get: function get() {\n        /** @type {?} */\n        var results = [];\n        this.registry.forEach(\n        /**\n        * @param {?} mql\n        * @param {?} key\n        * @return {?}\n        */\n        function (mql, key) {\n          if (mql.matches) {\n            results.push(key);\n          }\n        });\n        return results;\n      }\n      /**\n       * For the specified mediaQuery?\n       * @param {?} mediaQuery\n       * @return {?}\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive(mediaQuery) {\n        /** @type {?} */\n        var mql = this.registry.get(mediaQuery);\n        return !!mql ? mql.matches : this.registerQuery(mediaQuery).some(\n        /**\n        * @param {?} m\n        * @return {?}\n        */\n\n        /**\n        * @param {?} m\n        * @return {?}\n        */\n        function (m) {\n          return m.matches;\n        });\n      }\n      /**\n       * External observers can watch for all (or a specific) mql changes.\n       * Typically used by the MediaQueryAdaptor; optionally available to components\n       * who wish to use the MediaMonitor as mediaMonitor$ observable service.\n       *\n       * Use deferred registration process to register breakpoints only on subscription\n       * This logic also enforces logic to register all mediaQueries BEFORE notify\n       * subscribers of notifications.\n       * @param {?=} mqList\n       * @param {?=} filterOthers\n       * @return {?}\n       */\n\n    }, {\n      key: \"observe\",\n      value: function observe(mqList) {\n        var _this3 = this;\n\n        var filterOthers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (mqList && mqList.length) {\n          /** @type {?} */\n          var matchMedia$ = this._observable$.pipe(filter(\n          /**\n          * @param {?} change\n          * @return {?}\n          */\n          function (change) {\n            return !filterOthers ? true : mqList.indexOf(change.mediaQuery) > -1;\n          }));\n          /** @type {?} */\n\n\n          var registration$ = new Observable(\n          /**\n          * @param {?} observer\n          * @return {?}\n          */\n          function (observer) {\n            // tslint:disable-line:max-line-length\n\n            /** @type {?} */\n            var matches = _this3.registerQuery(mqList);\n\n            if (matches.length) {\n              /** @type {?} */\n              var lastChange =\n              /** @type {?} */\n              matches.pop();\n              matches.forEach(\n              /**\n              * @param {?} e\n              * @return {?}\n              */\n              function (e) {\n                observer.next(e);\n              });\n\n              _this3.source.next(lastChange); // last match is cached\n\n            }\n\n            observer.complete();\n          });\n          return merge(registration$, matchMedia$);\n        }\n\n        return this._observable$;\n      }\n      /**\n       * Based on the BreakPointRegistry provider, register internal listeners for each unique\n       * mediaQuery. Each listener emits specific MediaChange data to observers\n       * @param {?} mediaQuery\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerQuery\",\n      value: function registerQuery(mediaQuery) {\n        var _this4 = this;\n\n        /** @type {?} */\n        var list = Array.isArray(mediaQuery) ? mediaQuery : [mediaQuery];\n        /** @type {?} */\n\n        var matches = [];\n        buildQueryCss(list, this._document);\n        list.forEach(\n        /**\n        * @param {?} query\n        * @return {?}\n        */\n        function (query) {\n          /** @type {?} */\n          var onMQLEvent =\n          /**\n          * @param {?} e\n          * @return {?}\n          */\n          function onMQLEvent(e) {\n            _this4._zone.run(\n            /**\n            * @return {?}\n            */\n            function () {\n              return _this4.source.next(new MediaChange(e.matches, query));\n            });\n          };\n          /** @type {?} */\n\n\n          var mql = _this4.registry.get(query);\n\n          if (!mql) {\n            mql = _this4.buildMQL(query);\n            mql.addListener(onMQLEvent);\n\n            _this4.pendingRemoveListenerFns.push(\n            /**\n            * @return {?}\n            */\n            function () {\n              return (\n                /** @type {?} */\n                mql.removeListener(onMQLEvent)\n              );\n            });\n\n            _this4.registry.set(query, mql);\n          }\n\n          if (mql.matches) {\n            matches.push(new MediaChange(true, query));\n          }\n        });\n        return matches;\n      }\n      /**\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        /** @type {?} */\n        var fn;\n\n        while (fn = this.pendingRemoveListenerFns.pop()) {\n          fn();\n        }\n      }\n      /**\n       * Call window.matchMedia() to build a MediaQueryList; which\n       * supports 0..n listeners for activation/deactivation\n       * @protected\n       * @param {?} query\n       * @return {?}\n       */\n\n    }, {\n      key: \"buildMQL\",\n      value: function buildMQL(query) {\n        return constructMql(query, isPlatformBrowser(this._platformId));\n      }\n    }]);\n\n    return MatchMedia;\n  }();\n\n  MatchMedia.ɵfac = function MatchMedia_Factory(t) {\n    return new (t || MatchMedia)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n  /** @nocollapse */\n\n\n  MatchMedia.ɵprov = ɵɵdefineInjectable({\n    factory: function MatchMedia_Factory() {\n      return new MatchMedia(ɵɵinject(NgZone), ɵɵinject(PLATFORM_ID), ɵɵinject(DOCUMENT));\n    },\n    token: MatchMedia,\n    providedIn: \"root\"\n  });\n  return MatchMedia;\n}();\n/**\n * Private global registry for all dynamically-created, injected style tags\n * @see prepare(query)\n * @type {?}\n */\n\n\nvar ALL_STYLES = {};\n/**\n * For Webkit engines that only trigger the MediaQueryList Listener\n * when there is at least one CSS selector for the respective media query.\n *\n * @param {?} mediaQueries\n * @param {?} _document\n * @return {?}\n */\n\nfunction buildQueryCss(mediaQueries, _document) {\n  /** @type {?} */\n  var list = mediaQueries.filter(\n  /**\n  * @param {?} it\n  * @return {?}\n  */\n\n  /**\n  * @param {?} it\n  * @return {?}\n  */\n  function (it) {\n    return !ALL_STYLES[it];\n  });\n\n  if (list.length > 0) {\n    /** @type {?} */\n    var query = list.join(', ');\n\n    try {\n      /** @type {?} */\n      var styleEl = _document.createElement('style');\n\n      styleEl.setAttribute('type', 'text/css');\n\n      if (!\n      /** @type {?} */\n      styleEl.styleSheet) {\n        /** @type {?} */\n        var cssText = \"\\n/*\\n  @angular/flex-layout - workaround for possible browser quirk with mediaQuery listeners\\n  see http://bit.ly/2sd4HMP\\n*/\\n@media \".concat(query, \" {.fx-query-test{ }}\\n\");\n        styleEl.appendChild(_document.createTextNode(cssText));\n      }\n\n      /** @type {?} */\n      _document.head.appendChild(styleEl); // Store in private global registry\n\n\n      list.forEach(\n      /**\n      * @param {?} mq\n      * @return {?}\n      */\n\n      /**\n      * @param {?} mq\n      * @return {?}\n      */\n      function (mq) {\n        return ALL_STYLES[mq] = styleEl;\n      });\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n/**\n * @param {?} query\n * @param {?} isBrowser\n * @return {?}\n */\n\n\nfunction constructMql(query, isBrowser) {\n  /** @type {?} */\n  var canListen = isBrowser && !!\n  /** @type {?} */\n  window.matchMedia('all').addListener;\n  return canListen ?\n  /** @type {?} */\n  window.matchMedia(query) :\n  /** @type {?} */\n  {\n    matches: query === 'all' || query === '',\n    media: query,\n    addListener:\n    /**\n    * @return {?}\n    */\n    function addListener() {},\n    removeListener:\n    /**\n    * @return {?}\n    */\n    function removeListener() {},\n    onchange: null,\n\n    /**\n     * @return {?}\n     */\n    addEventListener: function addEventListener() {},\n\n    /**\n     * @return {?}\n     */\n    removeEventListener: function removeEventListener() {},\n\n    /**\n     * @return {?}\n     */\n    dispatchEvent: function dispatchEvent() {\n      return false;\n    }\n  };\n}\n\nvar MockMatchMedia = /*@__PURE__*/function () {\n  var MockMatchMedia = /*#__PURE__*/function (_MatchMedia) {\n    _inherits(MockMatchMedia, _MatchMedia);\n\n    var _super = _createSuper(MockMatchMedia);\n\n    // Allow fallback to overlapping mediaQueries\n\n    /**\n     * @param {?} _zone\n     * @param {?} _platformId\n     * @param {?} _document\n     * @param {?} _breakpoints\n     */\n    function MockMatchMedia(_zone, _platformId, _document, _breakpoints) {\n      var _this5;\n\n      _classCallCheck(this, MockMatchMedia);\n\n      _this5 = _super.call(this, _zone, _platformId, _document);\n      _this5._breakpoints = _breakpoints;\n      _this5.autoRegisterQueries = true; // Used for testing BreakPoint registrations\n      // Used for testing BreakPoint registrations\n\n      _this5.useOverlaps = false; // Allow fallback to overlapping mediaQueries\n\n      return _this5;\n    }\n    /**\n     * Easy method to clear all listeners for all mediaQueries\n     * @return {?}\n     */\n\n\n    _createClass(MockMatchMedia, [{\n      key: \"clearAll\",\n      value: function clearAll() {\n        this.registry.forEach(\n        /**\n        * @param {?} mql\n        * @return {?}\n        */\n        function (mql) {\n          /** @type {?} */\n          mql.destroy();\n        });\n        this.registry.clear();\n        this.useOverlaps = false;\n      }\n      /**\n       * Feature to support manual, simulated activation of a mediaQuery.\n       * @param {?} mediaQuery\n       * @param {?=} useOverlaps\n       * @return {?}\n       */\n\n    }, {\n      key: \"activate\",\n      value: function activate(mediaQuery) {\n        var useOverlaps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        useOverlaps = useOverlaps || this.useOverlaps;\n        mediaQuery = this._validateQuery(mediaQuery);\n\n        if (useOverlaps || !this.isActive(mediaQuery)) {\n          this._deactivateAll();\n\n          this._registerMediaQuery(mediaQuery);\n\n          this._activateWithOverlaps(mediaQuery, useOverlaps);\n        }\n\n        return this.hasActivated;\n      }\n      /**\n       * Converts an optional mediaQuery alias to a specific, valid mediaQuery\n       * @param {?} queryOrAlias\n       * @return {?}\n       */\n\n    }, {\n      key: \"_validateQuery\",\n      value: function _validateQuery(queryOrAlias) {\n        /** @type {?} */\n        var bp = this._breakpoints.findByAlias(queryOrAlias);\n\n        return bp && bp.mediaQuery || queryOrAlias;\n      }\n      /**\n       * Manually onMediaChange any overlapping mediaQueries to simulate\n       * similar functionality in the window.matchMedia()\n       * @private\n       * @param {?} mediaQuery\n       * @param {?} useOverlaps\n       * @return {?}\n       */\n\n    }, {\n      key: \"_activateWithOverlaps\",\n      value: function _activateWithOverlaps(mediaQuery, useOverlaps) {\n        if (useOverlaps) {\n          /** @type {?} */\n          var bp = this._breakpoints.findByQuery(mediaQuery);\n          /** @type {?} */\n\n\n          var alias = bp ? bp.alias : 'unknown'; // Simulate activation of overlapping lt-<XXX> ranges\n\n          switch (alias) {\n            case 'lg':\n              this._activateByAlias(['lt-xl']);\n\n              break;\n\n            case 'md':\n              this._activateByAlias(['lt-xl', 'lt-lg']);\n\n              break;\n\n            case 'sm':\n              this._activateByAlias(['lt-xl', 'lt-lg', 'lt-md']);\n\n              break;\n\n            case 'xs':\n              this._activateByAlias(['lt-xl', 'lt-lg', 'lt-md', 'lt-sm']);\n\n              break;\n          } // Simulate activation of overlapping gt-<xxxx> mediaQuery ranges\n\n\n          switch (alias) {\n            case 'xl':\n              this._activateByAlias(['gt-lg', 'gt-md', 'gt-sm', 'gt-xs']);\n\n              break;\n\n            case 'lg':\n              this._activateByAlias(['gt-md', 'gt-sm', 'gt-xs']);\n\n              break;\n\n            case 'md':\n              this._activateByAlias(['gt-sm', 'gt-xs']);\n\n              break;\n\n            case 'sm':\n              this._activateByAlias(['gt-xs']);\n\n              break;\n          }\n        } // Activate last since the responsiveActivation is watching *this* mediaQuery\n\n\n        return this._activateByQuery(mediaQuery);\n      }\n      /**\n       *\n       * @private\n       * @param {?} aliases\n       * @return {?}\n       */\n\n    }, {\n      key: \"_activateByAlias\",\n      value: function _activateByAlias(aliases) {\n        var _this6 = this;\n\n        /** @type {?} */\n        var activate =\n        /**\n        * @param {?} alias\n        * @return {?}\n        */\n        function activate(alias) {\n          /** @type {?} */\n          var bp = _this6._breakpoints.findByAlias(alias);\n\n          _this6._activateByQuery(bp ? bp.mediaQuery : alias);\n        };\n\n        aliases.forEach(activate);\n      }\n      /**\n       *\n       * @private\n       * @param {?} mediaQuery\n       * @return {?}\n       */\n\n    }, {\n      key: \"_activateByQuery\",\n      value: function _activateByQuery(mediaQuery) {\n        if (!this.registry.has(mediaQuery) && this.autoRegisterQueries) {\n          this._registerMediaQuery(mediaQuery);\n        }\n        /** @type {?} */\n\n\n        var mql =\n        /** @type {?} */\n        this.registry.get(mediaQuery);\n\n        if (mql && !this.isActive(mediaQuery)) {\n          this.registry.set(mediaQuery, mql.activate());\n        }\n\n        return this.hasActivated;\n      }\n      /**\n       * Deactivate all current MQLs and reset the buffer\n       * @private\n       * @template THIS\n       * @this {THIS}\n       * @return {THIS}\n       */\n\n    }, {\n      key: \"_deactivateAll\",\n      value: function _deactivateAll() {\n        /** @type {?} */\n        this.registry.forEach(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        function (it) {\n          /** @type {?} */\n          it.deactivate();\n        });\n        return (\n          /** @type {?} */\n          this\n        );\n      }\n      /**\n       * Insure the mediaQuery is registered with MatchMedia\n       * @private\n       * @param {?} mediaQuery\n       * @return {?}\n       */\n\n    }, {\n      key: \"_registerMediaQuery\",\n      value: function _registerMediaQuery(mediaQuery) {\n        if (!this.registry.has(mediaQuery) && this.autoRegisterQueries) {\n          this.registerQuery(mediaQuery);\n        }\n      }\n      /**\n       * Call window.matchMedia() to build a MediaQueryList; which\n       * supports 0..n listeners for activation/deactivation\n       * @protected\n       * @param {?} query\n       * @return {?}\n       */\n\n    }, {\n      key: \"buildMQL\",\n      value: function buildMQL(query) {\n        return new MockMediaQueryList(query);\n      }\n      /**\n       * @protected\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasActivated\",\n      get: function get() {\n        return this.activations.length > 0;\n      }\n    }]);\n\n    return MockMatchMedia;\n  }(MatchMedia);\n\n  MockMatchMedia.ɵfac = function MockMatchMedia_Factory(t) {\n    return new (t || MockMatchMedia)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(BreakPointRegistry));\n  };\n\n  MockMatchMedia.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n    token: MockMatchMedia,\n    factory: MockMatchMedia.ɵfac\n  });\n  return MockMatchMedia;\n}();\n/**\n * Special internal class to simulate a MediaQueryList and\n * - supports manual activation to simulate mediaQuery matching\n * - manages listeners\n */\n\n\nvar MockMediaQueryList = /*#__PURE__*/function () {\n  /**\n   * @param {?} _mediaQuery\n   */\n  function MockMediaQueryList(_mediaQuery) {\n    _classCallCheck(this, MockMediaQueryList);\n\n    this._mediaQuery = _mediaQuery;\n    this._isActive = false;\n    this._listeners = [];\n    this.onchange = null;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  _createClass(MockMediaQueryList, [{\n    key: \"matches\",\n    get: function get() {\n      return this._isActive;\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"media\",\n    get: function get() {\n      return this._mediaQuery;\n    }\n    /**\n     * Destroy the current list by deactivating the\n     * listeners and clearing the internal list\n     * @return {?}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.deactivate();\n      this._listeners = [];\n    }\n    /**\n     * Notify all listeners that 'matches === TRUE'\n     * @return {?}\n     */\n\n  }, {\n    key: \"activate\",\n    value: function activate() {\n      var _this7 = this;\n\n      if (!this._isActive) {\n        this._isActive = true;\n\n        this._listeners.forEach(\n        /**\n        * @param {?} callback\n        * @return {?}\n        */\n        function (callback) {\n          /** @type {?} */\n          var cb =\n          /** @type {?} */\n          callback;\n          cb.call(_this7,\n          /** @type {?} */\n          {\n            matches: _this7.matches,\n            media: _this7.media\n          });\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Notify all listeners that 'matches === false'\n     * @return {?}\n     */\n\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      var _this8 = this;\n\n      if (this._isActive) {\n        this._isActive = false;\n\n        this._listeners.forEach(\n        /**\n        * @param {?} callback\n        * @return {?}\n        */\n        function (callback) {\n          /** @type {?} */\n          var cb =\n          /** @type {?} */\n          callback;\n          cb.call(_this8,\n          /** @type {?} */\n          {\n            matches: _this8.matches,\n            media: _this8.media\n          });\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Add a listener to our internal list to activate later\n     * @param {?} listener\n     * @return {?}\n     */\n\n  }, {\n    key: \"addListener\",\n    value: function addListener(listener) {\n      if (this._listeners.indexOf(listener) === -1) {\n        this._listeners.push(listener);\n      }\n\n      if (this._isActive) {\n        /** @type {?} */\n        var cb =\n        /** @type {?} */\n        listener;\n        cb.call(this,\n        /** @type {?} */\n        {\n          matches: this.matches,\n          media: this.media\n        });\n      }\n    }\n    /**\n     * Don't need to remove listeners in the testing environment\n     * @param {?} _\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(_) {}\n    /**\n     * @param {?} _\n     * @param {?} __\n     * @param {?=} ___\n     * @return {?}\n     */\n\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(_, __, ___) {}\n    /**\n     * @param {?} _\n     * @param {?} __\n     * @param {?=} ___\n     * @return {?}\n     */\n\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(_, __, ___) {}\n    /**\n     * @param {?} _\n     * @return {?}\n     */\n\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(_) {\n      return false;\n    }\n  }]);\n\n  return MockMediaQueryList;\n}();\n/**\n * Pre-configured provider for MockMatchMedia\n * @type {?}\n */\n\n\nvar MockMatchMediaProvider = {\n  // tslint:disable-line:variable-name\n  provide: MatchMedia,\n  useClass: MockMatchMedia\n};\n/**\n * @fileoverview added by tsickle\n * Generated from: core/match-media/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-marshaller/print-hook.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nvar PRINT = 'print';\n/** @type {?} */\n\nvar BREAKPOINT_PRINT = {\n  alias: PRINT,\n  mediaQuery: PRINT,\n  priority: 1000\n};\n\nvar PrintHook = /*@__PURE__*/function () {\n  var PrintHook = /*#__PURE__*/function () {\n    /**\n     * @param {?} breakpoints\n     * @param {?} layoutConfig\n     * @param {?} _document\n     */\n    function PrintHook(breakpoints, layoutConfig, _document) {\n      _classCallCheck(this, PrintHook);\n\n      this.breakpoints = breakpoints;\n      this.layoutConfig = layoutConfig;\n      this._document = _document; // registeredBeforeAfterPrintHooks tracks if we registered the `beforeprint`\n      //  and `afterprint` event listeners.\n\n      this.registeredBeforeAfterPrintHooks = false; // isPrintingBeforeAfterEvent is used to track if we are printing from within\n      // a `beforeprint` event handler. This prevents the typicall `stopPrinting`\n      // form `interceptEvents` so that printing is not stopped while the dialog\n      // is still open. This is an extension of the `isPrinting` property on\n      // browsers which support `beforeprint` and `afterprint` events.\n\n      this.isPrintingBeforeAfterEvent = false;\n      this.beforePrintEventListeners = [];\n      this.afterPrintEventListeners = [];\n      /**\n       * Is this service currently in Print-mode ?\n       */\n\n      this.isPrinting = false;\n      this.queue = new PrintQueue();\n      this.deactivations = [];\n    }\n    /**\n     * Add 'print' mediaQuery: to listen for matchMedia activations\n     * @param {?} queries\n     * @return {?}\n     */\n\n\n    _createClass(PrintHook, [{\n      key: \"withPrintQuery\",\n      value: function withPrintQuery(queries) {\n        return [].concat(_toConsumableArray(queries), [PRINT]);\n      }\n      /**\n       * Is the MediaChange event for any 'print' \\@media\n       * @param {?} e\n       * @return {?}\n       */\n\n    }, {\n      key: \"isPrintEvent\",\n      value: function isPrintEvent(e) {\n        return e.mediaQuery.startsWith(PRINT);\n      }\n      /**\n       * What is the desired mqAlias to use while printing?\n       * @return {?}\n       */\n\n    }, {\n      key: \"printAlias\",\n      get: function get() {\n        return this.layoutConfig.printWithBreakpoints || [];\n      }\n      /**\n       * Lookup breakpoints associated with print aliases.\n       * @return {?}\n       */\n\n    }, {\n      key: \"printBreakPoints\",\n      get: function get() {\n        var _this9 = this;\n\n        return (\n          /** @type {?} */\n          this.printAlias.map(\n          /**\n          * @param {?} alias\n          * @return {?}\n          */\n\n          /**\n          * @param {?} alias\n          * @return {?}\n          */\n          function (alias) {\n            return _this9.breakpoints.findByAlias(alias);\n          }).filter(\n          /**\n          * @param {?} bp\n          * @return {?}\n          */\n\n          /**\n          * @param {?} bp\n          * @return {?}\n          */\n          function (bp) {\n            return bp !== null;\n          })\n        );\n      }\n      /**\n       * Lookup breakpoint associated with mediaQuery\n       * @param {?} __0\n       * @return {?}\n       */\n\n    }, {\n      key: \"getEventBreakpoints\",\n      value: function getEventBreakpoints(_ref) {\n        var mediaQuery = _ref.mediaQuery;\n\n        /** @type {?} */\n        var bp = this.breakpoints.findByQuery(mediaQuery);\n        /** @type {?} */\n\n        var list = bp ? [].concat(_toConsumableArray(this.printBreakPoints), [bp]) : this.printBreakPoints;\n        return list.sort(sortDescendingPriority);\n      }\n      /**\n       * Update event with printAlias mediaQuery information\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateEvent\",\n      value: function updateEvent(event) {\n        /** @type {?} */\n        var bp = this.breakpoints.findByQuery(event.mediaQuery);\n\n        if (this.isPrintEvent(event)) {\n          // Reset from 'print' to first (highest priority) print breakpoint\n          bp = this.getEventBreakpoints(event)[0];\n          event.mediaQuery = bp ? bp.mediaQuery : '';\n        }\n\n        return mergeAlias(event, bp);\n      } // registerBeforeAfterPrintHooks registers a `beforeprint` event hook so we can\n      // trigger print styles synchronously and apply proper layout styles.\n      // It is a noop if the hooks have already been registered or if the document's\n      // `defaultView` is not available.\n\n      /**\n       * @private\n       * @param {?} target\n       * @return {?}\n       */\n\n    }, {\n      key: \"registerBeforeAfterPrintHooks\",\n      value: function registerBeforeAfterPrintHooks(target) {\n        var _this10 = this;\n\n        // `defaultView` may be null when rendering on the server or in other contexts.\n        if (!this._document.defaultView || this.registeredBeforeAfterPrintHooks) {\n          return;\n        }\n\n        this.registeredBeforeAfterPrintHooks = true;\n        /** @type {?} */\n\n        var beforePrintListener =\n        /**\n        * @return {?}\n        */\n        function beforePrintListener() {\n          // If we aren't already printing, start printing and update the styles as\n          // if there was a regular print `MediaChange`(from matchMedia).\n          if (!_this10.isPrinting) {\n            _this10.isPrintingBeforeAfterEvent = true;\n\n            _this10.startPrinting(target, _this10.getEventBreakpoints(new MediaChange(true, PRINT)));\n\n            target.updateStyles();\n          }\n        };\n        /** @type {?} */\n\n\n        var afterPrintListener =\n        /**\n        * @return {?}\n        */\n        function afterPrintListener() {\n          // If we aren't already printing, start printing and update the styles as\n          // if there was a regular print `MediaChange`(from matchMedia).\n          _this10.isPrintingBeforeAfterEvent = false;\n\n          if (_this10.isPrinting) {\n            _this10.stopPrinting(target);\n\n            target.updateStyles();\n          }\n        }; // Could we have teardown logic to remove if there are no print listeners being used?\n\n\n        this._document.defaultView.addEventListener('beforeprint', beforePrintListener);\n\n        this._document.defaultView.addEventListener('afterprint', afterPrintListener);\n\n        this.beforePrintEventListeners.push(beforePrintListener);\n        this.afterPrintEventListeners.push(afterPrintListener);\n      }\n      /**\n       * Prepare RxJS filter operator with partial application\n       * @param {?} target\n       * @return {?} pipeable filter predicate\n       */\n\n    }, {\n      key: \"interceptEvents\",\n      value: function interceptEvents(target) {\n        var _this11 = this;\n\n        this.registerBeforeAfterPrintHooks(target);\n        return (\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            if (_this11.isPrintEvent(event)) {\n              if (event.matches && !_this11.isPrinting) {\n                _this11.startPrinting(target, _this11.getEventBreakpoints(event));\n\n                target.updateStyles();\n              } else if (!event.matches && _this11.isPrinting && !_this11.isPrintingBeforeAfterEvent) {\n                _this11.stopPrinting(target);\n\n                target.updateStyles();\n              }\n            } else {\n              _this11.collectActivations(event);\n            }\n          }\n        );\n      }\n      /**\n       * Stop mediaChange event propagation in event streams\n       * @return {?}\n       */\n\n    }, {\n      key: \"blockPropagation\",\n      value: function blockPropagation() {\n        var _this12 = this;\n\n        return (\n          /**\n          * @param {?} event\n          * @return {?}\n          */\n          function (event) {\n            return !(_this12.isPrinting || _this12.isPrintEvent(event));\n          }\n        );\n      }\n      /**\n       * Save current activateBreakpoints (for later restore)\n       * and substitute only the printAlias breakpoint\n       * @protected\n       * @param {?} target\n       * @param {?} bpList\n       * @return {?}\n       */\n\n    }, {\n      key: \"startPrinting\",\n      value: function startPrinting(target, bpList) {\n        this.isPrinting = true;\n        target.activatedBreakpoints = this.queue.addPrintBreakpoints(bpList);\n      }\n      /**\n       * For any print de-activations, reset the entire print queue\n       * @protected\n       * @param {?} target\n       * @return {?}\n       */\n\n    }, {\n      key: \"stopPrinting\",\n      value: function stopPrinting(target) {\n        target.activatedBreakpoints = this.deactivations;\n        this.deactivations = [];\n        this.queue.clear();\n        this.isPrinting = false;\n      }\n      /**\n       * To restore pre-Print Activations, we must capture the proper\n       * list of breakpoint activations BEFORE print starts. OnBeforePrint()\n       * is supported; so 'print' mediaQuery activations are used as a fallback\n       * in browsers without `beforeprint` support.\n       *\n       * >  But activated breakpoints are deactivated BEFORE 'print' activation.\n       *\n       * Let's capture all de-activations using the following logic:\n       *\n       *  When not printing:\n       *    - clear cache when activating non-print breakpoint\n       *    - update cache (and sort) when deactivating\n       *\n       *  When printing:\n       *    - sort and save when starting print\n       *    - restore as activatedTargets and clear when stop printing\n       * @param {?} event\n       * @return {?}\n       */\n\n    }, {\n      key: \"collectActivations\",\n      value: function collectActivations(event) {\n        if (!this.isPrinting || this.isPrintingBeforeAfterEvent) {\n          if (!event.matches) {\n            /** @type {?} */\n            var bp = this.breakpoints.findByQuery(event.mediaQuery);\n\n            if (bp) {\n              // Deactivating a breakpoint\n              this.deactivations.push(bp);\n              this.deactivations.sort(sortDescendingPriority);\n            }\n          } else if (!this.isPrintingBeforeAfterEvent) {\n            // Only clear deactivations if we aren't printing from a `beforeprint` event.\n            // Otherwise this will clear before `stopPrinting()` is called to restore\n            // the pre-Print Activations.\n            this.deactivations = [];\n          }\n        }\n      }\n      /**\n       * Teardown logic for the service.\n       * @return {?}\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        var _this13 = this;\n\n        this.beforePrintEventListeners.forEach(\n        /**\n        * @param {?} l\n        * @return {?}\n        */\n\n        /**\n        * @param {?} l\n        * @return {?}\n        */\n        function (l) {\n          return _this13._document.defaultView.removeEventListener('beforeprint', l);\n        });\n        this.afterPrintEventListeners.forEach(\n        /**\n        * @param {?} l\n        * @return {?}\n        */\n\n        /**\n        * @param {?} l\n        * @return {?}\n        */\n        function (l) {\n          return _this13._document.defaultView.removeEventListener('afterprint', l);\n        });\n      }\n    }]);\n\n    return PrintHook;\n  }();\n\n  PrintHook.ɵfac = function PrintHook_Factory(t) {\n    return new (t || PrintHook)(ɵngcc0.ɵɵinject(BreakPointRegistry), ɵngcc0.ɵɵinject(LAYOUT_CONFIG), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n  /** @nocollapse */\n\n\n  PrintHook.ɵprov = ɵɵdefineInjectable({\n    factory: function PrintHook_Factory() {\n      return new PrintHook(ɵɵinject(BreakPointRegistry), ɵɵinject(LAYOUT_CONFIG), ɵɵinject(DOCUMENT));\n    },\n    token: PrintHook,\n    providedIn: \"root\"\n  });\n  return PrintHook;\n}(); // ************************************************************************\n// Internal Utility class 'PrintQueue'\n// ************************************************************************\n\n/**\n * Utility class to manage print breakpoints + activatedBreakpoints\n * with correct sorting WHILE printing\n */\n\n\nvar PrintQueue = /*#__PURE__*/function () {\n  function PrintQueue() {\n    _classCallCheck(this, PrintQueue);\n\n    /**\n     * Sorted queue with prioritized print breakpoints\n     */\n    this.printBreakpoints = [];\n  }\n  /**\n   * @param {?} bpList\n   * @return {?}\n   */\n\n\n  _createClass(PrintQueue, [{\n    key: \"addPrintBreakpoints\",\n    value: function addPrintBreakpoints(bpList) {\n      var _this14 = this;\n\n      bpList.push(BREAKPOINT_PRINT);\n      bpList.sort(sortDescendingPriority);\n      bpList.forEach(\n      /**\n      * @param {?} bp\n      * @return {?}\n      */\n\n      /**\n      * @param {?} bp\n      * @return {?}\n      */\n      function (bp) {\n        return _this14.addBreakpoint(bp);\n      });\n      return this.printBreakpoints;\n    }\n    /**\n     * Add Print breakpoint to queue\n     * @param {?} bp\n     * @return {?}\n     */\n\n  }, {\n    key: \"addBreakpoint\",\n    value: function addBreakpoint(bp) {\n      if (!!bp) {\n        /** @type {?} */\n        var bpInList = this.printBreakpoints.find(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        function (it) {\n          return it.mediaQuery === bp.mediaQuery;\n        });\n\n        if (bpInList === undefined) {\n          // If this is a `printAlias` breakpoint, then append. If a true 'print' breakpoint,\n          // register as highest priority in the queue\n          this.printBreakpoints = isPrintBreakPoint(bp) ? [bp].concat(_toConsumableArray(this.printBreakpoints)) : [].concat(_toConsumableArray(this.printBreakpoints), [bp]);\n        }\n      }\n    }\n    /**\n     * Restore original activated breakpoints and clear internal caches\n     * @return {?}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.printBreakpoints = [];\n    }\n  }]);\n\n  return PrintQueue;\n}(); // ************************************************************************\n// Internal Utility methods\n// ************************************************************************\n\n/**\n * Only support intercept queueing if the Breakpoint is a print \\@media query\n * @param {?} bp\n * @return {?}\n */\n\n\nfunction isPrintBreakPoint(bp) {\n  return bp ? bp.mediaQuery.startsWith(PRINT) : false;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: core/utils/array.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Wraps the provided value in an array, unless the provided value is an array.\n * @template T\n * @param {?} value\n * @return {?}\n */\n\n\nfunction coerceArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nvar MediaObserver = /*@__PURE__*/function () {\n  var MediaObserver = /*#__PURE__*/function () {\n    /**\n     * @param {?} breakpoints\n     * @param {?} matchMedia\n     * @param {?} hook\n     */\n    function MediaObserver(breakpoints, matchMedia, hook) {\n      _classCallCheck(this, MediaObserver);\n\n      this.breakpoints = breakpoints;\n      this.matchMedia = matchMedia;\n      this.hook = hook;\n      /**\n       * Filter MediaChange notifications for overlapping breakpoints\n       */\n\n      this.filterOverlaps = false;\n      this.destroyed$ = new Subject();\n      this._media$ = this.watchActivations();\n      this.media$ = this._media$.pipe(filter(\n      /**\n      * @param {?} changes\n      * @return {?}\n      */\n      function (changes) {\n        return changes.length > 0;\n      }), map(\n      /**\n      * @param {?} changes\n      * @return {?}\n      */\n      function (changes) {\n        return changes[0];\n      }));\n    }\n    /**\n     * Completes the active subject, signalling to all complete for all\n     * MediaObserver subscribers\n     * @return {?}\n     */\n\n\n    _createClass(MediaObserver, [{\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.destroyed$.next();\n        this.destroyed$.complete();\n      } // ************************************************\n      // Public Methods\n      // ************************************************\n\n      /**\n       * Observe changes to current activation 'list'\n       * @return {?}\n       */\n\n    }, {\n      key: \"asObservable\",\n      value: function asObservable() {\n        return this._media$;\n      }\n      /**\n       * Allow programmatic query to determine if one or more media query/alias match\n       * the current viewport size.\n       * @param {?} value One or more media queries (or aliases) to check.\n       * @return {?} Whether any of the media queries match.\n       */\n\n    }, {\n      key: \"isActive\",\n      value: function isActive(value) {\n        var _this15 = this;\n\n        /** @type {?} */\n        var aliases = splitQueries(coerceArray(value));\n        return aliases.some(\n        /**\n        * @param {?} alias\n        * @return {?}\n        */\n\n        /**\n        * @param {?} alias\n        * @return {?}\n        */\n        function (alias) {\n          /** @type {?} */\n          var query = toMediaQuery(alias, _this15.breakpoints);\n          return query !== null && _this15.matchMedia.isActive(query);\n        });\n      } // ************************************************\n      // Internal Methods\n      // ************************************************\n\n      /**\n       * Register all the mediaQueries registered in the BreakPointRegistry\n       * This is needed so subscribers can be auto-notified of all standard, registered\n       * mediaQuery activations\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"watchActivations\",\n      value: function watchActivations() {\n        /** @type {?} */\n        var queries = this.breakpoints.items.map(\n        /**\n        * @param {?} bp\n        * @return {?}\n        */\n\n        /**\n        * @param {?} bp\n        * @return {?}\n        */\n        function (bp) {\n          return bp.mediaQuery;\n        });\n        return this.buildObservable(queries);\n      }\n      /**\n       * Only pass/announce activations (not de-activations)\n       *\n       * Since multiple-mediaQueries can be activation in a cycle,\n       * gather all current activations into a single list of changes to observers\n       *\n       * Inject associated (if any) alias information into the MediaChange event\n       * - Exclude mediaQuery activations for overlapping mQs. List bounded mQ ranges only\n       * - Exclude print activations that do not have an associated mediaQuery\n       *\n       * NOTE: the raw MediaChange events [from MatchMedia] do not\n       *       contain important alias information; as such this info\n       *       must be injected into the MediaChange\n       * @private\n       * @param {?} mqList\n       * @return {?}\n       */\n\n    }, {\n      key: \"buildObservable\",\n      value: function buildObservable(mqList) {\n        var _this16 = this;\n\n        /** @type {?} */\n        var hasChanges =\n        /**\n        * @param {?} changes\n        * @return {?}\n        */\n        function hasChanges(changes) {\n          /** @type {?} */\n          var isValidQuery =\n          /**\n          * @param {?} change\n          * @return {?}\n          */\n          function isValidQuery(change) {\n            return change.mediaQuery.length > 0;\n          };\n\n          return changes.filter(isValidQuery).length > 0;\n        };\n        /** @type {?} */\n\n\n        var excludeOverlaps =\n        /**\n        * @param {?} changes\n        * @return {?}\n        */\n        function excludeOverlaps(changes) {\n          return !_this16.filterOverlaps ? changes : changes.filter(\n          /**\n          * @param {?} change\n          * @return {?}\n          */\n\n          /**\n          * @param {?} change\n          * @return {?}\n          */\n          function (change) {\n            /** @type {?} */\n            var bp = _this16.breakpoints.findByQuery(change.mediaQuery);\n\n            return !bp ? true : !bp.overlapping;\n          });\n        };\n        /**\n         */\n\n\n        return this.matchMedia.observe(this.hook.withPrintQuery(mqList)).pipe(filter(\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        function (change) {\n          return change.matches;\n        }), debounceTime(0, asapScheduler), switchMap(\n        /**\n        * @param {?} _\n        * @return {?}\n        */\n\n        /**\n        * @param {?} _\n        * @return {?}\n        */\n        function (_) {\n          return of(_this16.findAllActivations());\n        }), map(excludeOverlaps), filter(hasChanges), takeUntil(this.destroyed$));\n      }\n      /**\n       * Find all current activations and prepare single list of activations\n       * sorted by descending priority.\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"findAllActivations\",\n      value: function findAllActivations() {\n        var _this17 = this;\n\n        /** @type {?} */\n        var mergeMQAlias =\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        function mergeMQAlias(change) {\n          /** @type {?} */\n          var bp = _this17.breakpoints.findByQuery(change.mediaQuery);\n\n          return mergeAlias(change, bp);\n        };\n        /** @type {?} */\n\n\n        var replaceWithPrintAlias =\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        function replaceWithPrintAlias(change) {\n          return _this17.hook.isPrintEvent(change) ? _this17.hook.updateEvent(change) : change;\n        };\n\n        return this.matchMedia.activations.map(\n        /**\n        * @param {?} query\n        * @return {?}\n        */\n\n        /**\n        * @param {?} query\n        * @return {?}\n        */\n        function (query) {\n          return new MediaChange(true, query);\n        }).map(replaceWithPrintAlias).map(mergeMQAlias).sort(sortDescendingPriority);\n      }\n    }]);\n\n    return MediaObserver;\n  }();\n\n  MediaObserver.ɵfac = function MediaObserver_Factory(t) {\n    return new (t || MediaObserver)(ɵngcc0.ɵɵinject(BreakPointRegistry), ɵngcc0.ɵɵinject(MatchMedia), ɵngcc0.ɵɵinject(PrintHook));\n  };\n  /** @nocollapse */\n\n\n  MediaObserver.ɵprov = ɵɵdefineInjectable({\n    factory: function MediaObserver_Factory() {\n      return new MediaObserver(ɵɵinject(BreakPointRegistry), ɵɵinject(MatchMedia), ɵɵinject(PrintHook));\n    },\n    token: MediaObserver,\n    providedIn: \"root\"\n  });\n  return MediaObserver;\n}();\n/**\n * Find associated breakpoint (if any)\n * @param {?} query\n * @param {?} locator\n * @return {?}\n */\n\n\nfunction toMediaQuery(query, locator) {\n  /** @type {?} */\n  var bp = locator.findByAlias(query) || locator.findByQuery(query);\n  return bp ? bp.mediaQuery : null;\n}\n/**\n * Split each query string into separate query strings if two queries are provided as comma\n * separated.\n * @param {?} queries\n * @return {?}\n */\n\n\nfunction splitQueries(queries) {\n  return queries.map(\n  /**\n  * @param {?} query\n  * @return {?}\n  */\n  function (query) {\n    return query.split(',');\n  }).reduce(\n  /**\n  * @param {?} a1\n  * @param {?} a2\n  * @return {?}\n  */\n  function (a1, a2) {\n    return a1.concat(a2);\n  }).map(\n  /**\n  * @param {?} query\n  * @return {?}\n  */\n\n  /**\n  * @param {?} query\n  * @return {?}\n  */\n  function (query) {\n    return query.trim();\n  });\n}\n\nvar MediaTrigger = /*@__PURE__*/function () {\n  var MediaTrigger = /*#__PURE__*/function () {\n    /**\n     * @param {?} breakpoints\n     * @param {?} matchMedia\n     * @param {?} layoutConfig\n     * @param {?} _platformId\n     * @param {?} _document\n     */\n    function MediaTrigger(breakpoints, matchMedia, layoutConfig, _platformId, _document) {\n      _classCallCheck(this, MediaTrigger);\n\n      this.breakpoints = breakpoints;\n      this.matchMedia = matchMedia;\n      this.layoutConfig = layoutConfig;\n      this._platformId = _platformId;\n      this._document = _document;\n      this.hasCachedRegistryMatches = false;\n      this.originalActivations = [];\n      this.originalRegistry = new Map();\n    }\n    /**\n     * Manually activate range of breakpoints\n     * @param {?} list array of mediaQuery or alias strings\n     * @return {?}\n     */\n\n\n    _createClass(MediaTrigger, [{\n      key: \"activate\",\n      value: function activate(list) {\n        list = list.map(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        function (it) {\n          return it.trim();\n        }); // trim queries\n\n        this.saveActivations();\n        this.deactivateAll();\n        this.setActivations(list);\n        this.prepareAutoRestore();\n      }\n      /**\n       * Restore original, 'real' breakpoints and emit events\n       * to trigger stream notification\n       * @return {?}\n       */\n\n    }, {\n      key: \"restore\",\n      value: function restore() {\n        if (this.hasCachedRegistryMatches) {\n          /** @type {?} */\n          var extractQuery =\n          /**\n          * @param {?} change\n          * @return {?}\n          */\n          function extractQuery(change) {\n            return change.mediaQuery;\n          };\n          /** @type {?} */\n\n\n          var list = this.originalActivations.map(extractQuery);\n\n          try {\n            this.deactivateAll();\n            this.restoreRegistryMatches();\n            this.setActivations(list);\n          } finally {\n            this.originalActivations = [];\n\n            if (this.resizeSubscription) {\n              this.resizeSubscription.unsubscribe();\n            }\n          }\n        }\n      } // ************************************************\n      // Internal Methods\n      // ************************************************\n\n      /**\n       * Whenever window resizes, immediately auto-restore original\n       * activations (if we are simulating activations)\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"prepareAutoRestore\",\n      value: function prepareAutoRestore() {\n        /** @type {?} */\n        var isBrowser = isPlatformBrowser(this._platformId) && this._document;\n        /** @type {?} */\n\n\n        var enableAutoRestore = isBrowser && this.layoutConfig.mediaTriggerAutoRestore;\n\n        if (enableAutoRestore) {\n          /** @type {?} */\n          var resize$ = fromEvent(window, 'resize').pipe(take(1));\n          this.resizeSubscription = resize$.subscribe(this.restore.bind(this));\n        }\n      }\n      /**\n       * Notify all matchMedia subscribers of de-activations\n       *\n       * Note: we must force 'matches' updates for\n       *       future matchMedia::activation lookups\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"deactivateAll\",\n      value: function deactivateAll() {\n        /** @type {?} */\n        var list = this.currentActivations;\n        this.forceRegistryMatches(list, false);\n        this.simulateMediaChanges(list, false);\n      }\n      /**\n       * Cache current activations as sorted, prioritized list of MediaChanges\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"saveActivations\",\n      value: function saveActivations() {\n        var _this18 = this;\n\n        if (!this.hasCachedRegistryMatches) {\n          /** @type {?} */\n          var toMediaChange =\n          /**\n          * @param {?} query\n          * @return {?}\n          */\n          function toMediaChange(query) {\n            return new MediaChange(true, query);\n          };\n          /** @type {?} */\n\n\n          var mergeMQAlias =\n          /**\n          * @param {?} change\n          * @return {?}\n          */\n          function mergeMQAlias(change) {\n            /** @type {?} */\n            var bp = _this18.breakpoints.findByQuery(change.mediaQuery);\n\n            return mergeAlias(change, bp);\n          };\n\n          this.originalActivations = this.currentActivations.map(toMediaChange).map(mergeMQAlias).sort(sortDescendingPriority);\n          this.cacheRegistryMatches();\n        }\n      }\n      /**\n       * Force set manual activations for specified mediaQuery list\n       * @private\n       * @param {?} list\n       * @return {?}\n       */\n\n    }, {\n      key: \"setActivations\",\n      value: function setActivations(list) {\n        if (!!this.originalRegistry) {\n          this.forceRegistryMatches(list, true);\n        }\n\n        this.simulateMediaChanges(list);\n      }\n      /**\n       * For specified mediaQuery list manually simulate activations or deactivations\n       * @private\n       * @param {?} queries\n       * @param {?=} matches\n       * @return {?}\n       */\n\n    }, {\n      key: \"simulateMediaChanges\",\n      value: function simulateMediaChanges(queries) {\n        var _this19 = this;\n\n        var matches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        /** @type {?} */\n        var toMediaQuery =\n        /**\n        * @param {?} query\n        * @return {?}\n        */\n        function toMediaQuery(query) {\n          /** @type {?} */\n          var locator = _this19.breakpoints;\n          /** @type {?} */\n\n          var bp = locator.findByAlias(query) || locator.findByQuery(query);\n          return bp ? bp.mediaQuery : query;\n        };\n        /** @type {?} */\n\n\n        var emitChangeEvent =\n        /**\n        * @param {?} query\n        * @return {?}\n        */\n        function emitChangeEvent(query) {\n          return _this19.emitChangeEvent(matches, query);\n        };\n\n        queries.map(toMediaQuery).forEach(emitChangeEvent);\n      }\n      /**\n       * Replace current registry with simulated registry...\n       * Note: this is required since MediaQueryList::matches is 'readOnly'\n       * @private\n       * @param {?} queries\n       * @param {?} matches\n       * @return {?}\n       */\n\n    }, {\n      key: \"forceRegistryMatches\",\n      value: function forceRegistryMatches(queries, matches) {\n        /** @type {?} */\n        var registry = new Map();\n        queries.forEach(\n        /**\n        * @param {?} query\n        * @return {?}\n        */\n\n        /**\n        * @param {?} query\n        * @return {?}\n        */\n        function (query) {\n          registry.set(query,\n          /** @type {?} */\n          {\n            matches: matches\n          });\n        });\n        this.matchMedia.registry = registry;\n      }\n      /**\n       * Save current MatchMedia::registry items.\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"cacheRegistryMatches\",\n      value: function cacheRegistryMatches() {\n        /** @type {?} */\n        var target = this.originalRegistry;\n        target.clear();\n        this.matchMedia.registry.forEach(\n        /**\n        * @param {?} value\n        * @param {?} key\n        * @return {?}\n        */\n        function (value, key) {\n          target.set(key, value);\n        });\n        this.hasCachedRegistryMatches = true;\n      }\n      /**\n       * Restore original, 'true' registry\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"restoreRegistryMatches\",\n      value: function restoreRegistryMatches() {\n        /** @type {?} */\n        var target = this.matchMedia.registry;\n        target.clear();\n        this.originalRegistry.forEach(\n        /**\n        * @param {?} value\n        * @param {?} key\n        * @return {?}\n        */\n        function (value, key) {\n          target.set(key, value);\n        });\n        this.originalRegistry.clear();\n        this.hasCachedRegistryMatches = false;\n      }\n      /**\n       * Manually emit a MediaChange event via the MatchMedia to MediaMarshaller and MediaObserver\n       * @private\n       * @param {?} matches\n       * @param {?} query\n       * @return {?}\n       */\n\n    }, {\n      key: \"emitChangeEvent\",\n      value: function emitChangeEvent(matches, query) {\n        this.matchMedia.source.next(new MediaChange(matches, query));\n      }\n      /**\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"currentActivations\",\n      get: function get() {\n        return this.matchMedia.activations;\n      }\n    }]);\n\n    return MediaTrigger;\n  }();\n\n  MediaTrigger.ɵfac = function MediaTrigger_Factory(t) {\n    return new (t || MediaTrigger)(ɵngcc0.ɵɵinject(BreakPointRegistry), ɵngcc0.ɵɵinject(MatchMedia), ɵngcc0.ɵɵinject(LAYOUT_CONFIG), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n  /** @nocollapse */\n\n\n  MediaTrigger.ɵprov = ɵɵdefineInjectable({\n    factory: function MediaTrigger_Factory() {\n      return new MediaTrigger(ɵɵinject(BreakPointRegistry), ɵɵinject(MatchMedia), ɵɵinject(LAYOUT_CONFIG), ɵɵinject(PLATFORM_ID), ɵɵinject(DOCUMENT));\n    },\n    token: MediaTrigger,\n    providedIn: \"root\"\n  });\n  return MediaTrigger;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/media-trigger/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/utils/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: utils/auto-prefixer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Applies CSS prefixes to appropriate style keys.\n *\n * Note: `-ms-`, `-moz` and `-webkit-box` are no longer supported. e.g.\n *    {\n *      display: -webkit-flex;     NEW - Safari 6.1+. iOS 7.1+, BB10\n *      display: flex;             NEW, Spec - Firefox, Chrome, Opera\n *      // display: -webkit-box;   OLD - iOS 6-, Safari 3.1-6, BB7\n *      // display: -ms-flexbox;   TWEENER - IE 10\n *      // display: -moz-flexbox;  OLD - Firefox\n *    }\n * @param {?} target\n * @return {?}\n */\n\n\nfunction applyCssPrefixes(target) {\n  for (var key in target) {\n    /** @type {?} */\n    var value = target[key] || '';\n\n    switch (key) {\n      case 'display':\n        if (value === 'flex') {\n          target['display'] = ['-webkit-flex', 'flex'];\n        } else if (value === 'inline-flex') {\n          target['display'] = ['-webkit-inline-flex', 'inline-flex'];\n        } else {\n          target['display'] = value;\n        }\n\n        break;\n\n      case 'align-items':\n      case 'align-self':\n      case 'align-content':\n      case 'flex':\n      case 'flex-basis':\n      case 'flex-flow':\n      case 'flex-grow':\n      case 'flex-shrink':\n      case 'flex-wrap':\n      case 'justify-content':\n        target['-webkit-' + key] = value;\n        break;\n\n      case 'flex-direction':\n        value = value || 'row';\n        target['-webkit-flex-direction'] = value;\n        target['flex-direction'] = value;\n        break;\n\n      case 'order':\n        target['order'] = target['-webkit-' + key] = isNaN(+value) ? '0' : value;\n        break;\n    }\n  }\n\n  return target;\n}\n\nvar StyleUtils = /*@__PURE__*/function () {\n  var StyleUtils = /*#__PURE__*/function () {\n    /**\n     * @param {?} _serverStylesheet\n     * @param {?} _serverModuleLoaded\n     * @param {?} _platformId\n     * @param {?} layoutConfig\n     */\n    function StyleUtils(_serverStylesheet, _serverModuleLoaded, _platformId, layoutConfig) {\n      _classCallCheck(this, StyleUtils);\n\n      this._serverStylesheet = _serverStylesheet;\n      this._serverModuleLoaded = _serverModuleLoaded;\n      this._platformId = _platformId;\n      this.layoutConfig = layoutConfig;\n    }\n    /**\n     * Applies styles given via string pair or object map to the directive element\n     * @param {?} element\n     * @param {?} style\n     * @param {?=} value\n     * @return {?}\n     */\n\n\n    _createClass(StyleUtils, [{\n      key: \"applyStyleToElement\",\n      value: function applyStyleToElement(element, style) {\n        var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        /** @type {?} */\n        var styles = {};\n\n        if (typeof style === 'string') {\n          styles[style] = value;\n          style = styles;\n        }\n\n        styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);\n\n        this._applyMultiValueStyleToElement(styles, element);\n      }\n      /**\n       * Applies styles given via string pair or object map to the directive's element\n       * @param {?} style\n       * @param {?=} elements\n       * @return {?}\n       */\n\n    }, {\n      key: \"applyStyleToElements\",\n      value: function applyStyleToElements(style) {\n        var _this20 = this;\n\n        var elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n        /** @type {?} */\n        var styles = this.layoutConfig.disableVendorPrefixes ? style : applyCssPrefixes(style);\n        elements.forEach(\n        /**\n        * @param {?} el\n        * @return {?}\n        */\n\n        /**\n        * @param {?} el\n        * @return {?}\n        */\n        function (el) {\n          _this20._applyMultiValueStyleToElement(styles, el);\n        });\n      }\n      /**\n       * Determine the DOM element's Flexbox flow (flex-direction)\n       *\n       * Check inline style first then check computed (stylesheet) style\n       * @param {?} target\n       * @return {?}\n       */\n\n    }, {\n      key: \"getFlowDirection\",\n      value: function getFlowDirection(target) {\n        /** @type {?} */\n        var query = 'flex-direction';\n        /** @type {?} */\n\n        var value = this.lookupStyle(target, query);\n        /** @type {?} */\n\n        var hasInlineValue = this.lookupInlineStyle(target, query) || isPlatformServer(this._platformId) && this._serverModuleLoaded ? value : '';\n        return [value || 'row', hasInlineValue];\n      }\n      /**\n       * @param {?} target\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasWrap\",\n      value: function hasWrap(target) {\n        /** @type {?} */\n        var query = 'flex-wrap';\n        return this.lookupStyle(target, query) === 'wrap';\n      }\n      /**\n       * Find the DOM element's raw attribute value (if any)\n       * @param {?} element\n       * @param {?} attribute\n       * @return {?}\n       */\n\n    }, {\n      key: \"lookupAttributeValue\",\n      value: function lookupAttributeValue(element, attribute) {\n        return element.getAttribute(attribute) || '';\n      }\n      /**\n       * Find the DOM element's inline style value (if any)\n       * @param {?} element\n       * @param {?} styleName\n       * @return {?}\n       */\n\n    }, {\n      key: \"lookupInlineStyle\",\n      value: function lookupInlineStyle(element, styleName) {\n        return isPlatformBrowser(this._platformId) ? element.style.getPropertyValue(styleName) : this._getServerStyle(element, styleName);\n      }\n      /**\n       * Determine the inline or inherited CSS style\n       * NOTE: platform-server has no implementation for getComputedStyle\n       * @param {?} element\n       * @param {?} styleName\n       * @param {?=} inlineOnly\n       * @return {?}\n       */\n\n    }, {\n      key: \"lookupStyle\",\n      value: function lookupStyle(element, styleName) {\n        var inlineOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        /** @type {?} */\n        var value = '';\n\n        if (element) {\n          /** @type {?} */\n          var immediateValue = value = this.lookupInlineStyle(element, styleName);\n\n          if (!immediateValue) {\n            if (isPlatformBrowser(this._platformId)) {\n              if (!inlineOnly) {\n                value = getComputedStyle(element).getPropertyValue(styleName);\n              }\n            } else {\n              if (this._serverModuleLoaded) {\n                value = this._serverStylesheet.getStyleForElement(element, styleName);\n              }\n            }\n          }\n        } // Note: 'inline' is the default of all elements, unless UA stylesheet overrides;\n        //       in which case getComputedStyle() should determine a valid value.\n\n\n        return value ? value.trim() : '';\n      }\n      /**\n       * Applies the styles to the element. The styles object map may contain an array of values\n       * Each value will be added as element style\n       * Keys are sorted to add prefixed styles (like -webkit-x) first, before the standard ones\n       * @private\n       * @param {?} styles\n       * @param {?} element\n       * @return {?}\n       */\n\n    }, {\n      key: \"_applyMultiValueStyleToElement\",\n      value: function _applyMultiValueStyleToElement(styles, element) {\n        var _this21 = this;\n\n        Object.keys(styles).sort().forEach(\n        /**\n        * @param {?} key\n        * @return {?}\n        */\n\n        /**\n        * @param {?} key\n        * @return {?}\n        */\n        function (key) {\n          /** @type {?} */\n          var el = styles[key];\n          /** @type {?} */\n\n          var values = Array.isArray(el) ? el : [el];\n          values.sort();\n\n          var _iterator = _createForOfIteratorHelper(values),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var value = _step.value;\n              value = value ? value + '' : '';\n\n              if (isPlatformBrowser(_this21._platformId) || !_this21._serverModuleLoaded) {\n                isPlatformBrowser(_this21._platformId) ? element.style.setProperty(key, value) : _this21._setServerStyle(element, key, value);\n              } else {\n                _this21._serverStylesheet.addStyleToElement(element, key, value);\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      }\n      /**\n       * @private\n       * @param {?} element\n       * @param {?} styleName\n       * @param {?=} styleValue\n       * @return {?}\n       */\n\n    }, {\n      key: \"_setServerStyle\",\n      value: function _setServerStyle(element, styleName, styleValue) {\n        styleName = styleName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n        /** @type {?} */\n\n        var styleMap = this._readStyleAttribute(element);\n\n        styleMap[styleName] = styleValue || '';\n\n        this._writeStyleAttribute(element, styleMap);\n      }\n      /**\n       * @private\n       * @param {?} element\n       * @param {?} styleName\n       * @return {?}\n       */\n\n    }, {\n      key: \"_getServerStyle\",\n      value: function _getServerStyle(element, styleName) {\n        /** @type {?} */\n        var styleMap = this._readStyleAttribute(element);\n\n        return styleMap[styleName] || '';\n      }\n      /**\n       * @private\n       * @param {?} element\n       * @return {?}\n       */\n\n    }, {\n      key: \"_readStyleAttribute\",\n      value: function _readStyleAttribute(element) {\n        /** @type {?} */\n        var styleMap = {};\n        /** @type {?} */\n\n        var styleAttribute = element.getAttribute('style');\n\n        if (styleAttribute) {\n          /** @type {?} */\n          var styleList = styleAttribute.split(/;+/g);\n\n          for (var i = 0; i < styleList.length; i++) {\n            /** @type {?} */\n            var style = styleList[i].trim();\n\n            if (style.length > 0) {\n              /** @type {?} */\n              var colonIndex = style.indexOf(':');\n\n              if (colonIndex === -1) {\n                throw new Error(\"Invalid CSS style: \".concat(style));\n              }\n              /** @type {?} */\n\n\n              var name = style.substr(0, colonIndex).trim();\n              styleMap[name] = style.substr(colonIndex + 1).trim();\n            }\n          }\n        }\n\n        return styleMap;\n      }\n      /**\n       * @private\n       * @param {?} element\n       * @param {?} styleMap\n       * @return {?}\n       */\n\n    }, {\n      key: \"_writeStyleAttribute\",\n      value: function _writeStyleAttribute(element, styleMap) {\n        /** @type {?} */\n        var styleAttrValue = '';\n\n        for (var key in styleMap) {\n          /** @type {?} */\n          var newValue = styleMap[key];\n\n          if (newValue) {\n            styleAttrValue += key + ':' + styleMap[key] + ';';\n          }\n        }\n\n        element.setAttribute('style', styleAttrValue);\n      }\n    }]);\n\n    return StyleUtils;\n  }();\n\n  StyleUtils.ɵfac = function StyleUtils_Factory(t) {\n    return new (t || StyleUtils)(ɵngcc0.ɵɵinject(StylesheetMap), ɵngcc0.ɵɵinject(SERVER_TOKEN), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(LAYOUT_CONFIG));\n  };\n  /** @nocollapse */\n\n\n  StyleUtils.ɵprov = ɵɵdefineInjectable({\n    factory: function StyleUtils_Factory() {\n      return new StyleUtils(ɵɵinject(StylesheetMap), ɵɵinject(SERVER_TOKEN), ɵɵinject(PLATFORM_ID), ɵɵinject(LAYOUT_CONFIG));\n    },\n    token: StyleUtils,\n    providedIn: \"root\"\n  });\n  return StyleUtils;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/style-builder/style-builder.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * A class that encapsulates CSS style generation for common directives\n * @abstract\n */\n\n\nvar StyleBuilder = /*#__PURE__*/function () {\n  function StyleBuilder() {\n    _classCallCheck(this, StyleBuilder);\n\n    /**\n     * Whether to cache the generated output styles\n     */\n    this.shouldCache = true;\n  }\n  /**\n   * Run a side effect computation given the input string and the computed styles\n   * from the build task and the host configuration object\n   * NOTE: This should be a no-op unless an algorithm is provided in a subclass\n   * @param {?} _input\n   * @param {?} _styles\n   * @param {?=} _parent\n   * @return {?}\n   */\n\n\n  _createClass(StyleBuilder, [{\n    key: \"sideEffect\",\n    value: function sideEffect(_input, _styles, _parent) {}\n  }]);\n\n  return StyleBuilder;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: core/basis-validator/basis-validator.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The flex API permits 3 or 1 parts of the value:\n *    - `flex-grow flex-shrink flex-basis`, or\n *    - `flex-basis`\n * @param {?} basis\n * @param {?=} grow\n * @param {?=} shrink\n * @return {?}\n */\n\n\nfunction validateBasis(basis) {\n  var grow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '1';\n  var shrink = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '1';\n\n  /** @type {?} */\n  var parts = [grow, shrink, basis];\n  /** @type {?} */\n\n  var j = basis.indexOf('calc');\n\n  if (j > 0) {\n    parts[2] = _validateCalcValue(basis.substring(j).trim());\n    /** @type {?} */\n\n    var matches = basis.substr(0, j).trim().split(' ');\n\n    if (matches.length == 2) {\n      parts[0] = matches[0];\n      parts[1] = matches[1];\n    }\n  } else if (j == 0) {\n    parts[2] = _validateCalcValue(basis.trim());\n  } else {\n    /** @type {?} */\n    var _matches = basis.split(' ');\n\n    parts = _matches.length === 3 ? _matches : [grow, shrink, basis];\n  }\n\n  return parts;\n}\n/**\n * Calc expressions require whitespace before & after any expression operators\n * This is a simple, crude whitespace padding solution.\n *   - '3 3 calc(15em + 20px)'\n *   - calc(100% / 7 * 2)\n *   - 'calc(15em + 20px)'\n *   - 'calc(15em+20px)'\n *   - '37px'\n *   = '43%'\n * @param {?} calc\n * @return {?}\n */\n\n\nfunction _validateCalcValue(calc) {\n  return calc.replace(/[\\s]/g, '').replace(/[\\/\\*\\+\\-]/g, ' $& ');\n}\n\nvar MediaMarshaller = /*@__PURE__*/function () {\n  var MediaMarshaller = /*#__PURE__*/function () {\n    /**\n     * @param {?} matchMedia\n     * @param {?} breakpoints\n     * @param {?} hook\n     */\n    function MediaMarshaller(matchMedia, breakpoints, hook) {\n      _classCallCheck(this, MediaMarshaller);\n\n      this.matchMedia = matchMedia;\n      this.breakpoints = breakpoints;\n      this.hook = hook;\n      this.activatedBreakpoints = [];\n      this.elementMap = new Map();\n      this.elementKeyMap = new WeakMap();\n      this.watcherMap = new WeakMap(); // special triggers to update elements\n      // special triggers to update elements\n\n      this.updateMap = new WeakMap(); // callback functions to update styles\n      // callback functions to update styles\n\n      this.clearMap = new WeakMap(); // callback functions to clear styles\n      // callback functions to clear styles\n\n      this.subject = new Subject();\n      this.observeActivations();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    _createClass(MediaMarshaller, [{\n      key: \"activatedAlias\",\n      get: function get() {\n        return this.activatedBreakpoints[0] ? this.activatedBreakpoints[0].alias : '';\n      }\n      /**\n       * Update styles on breakpoint activates or deactivates\n       * @param {?} mc\n       * @return {?}\n       */\n\n    }, {\n      key: \"onMediaChange\",\n      value: function onMediaChange(mc) {\n        /** @type {?} */\n        var bp = this.findByQuery(mc.mediaQuery);\n\n        if (bp) {\n          mc = mergeAlias(mc, bp);\n\n          if (mc.matches && this.activatedBreakpoints.indexOf(bp) === -1) {\n            this.activatedBreakpoints.push(bp);\n            this.activatedBreakpoints.sort(sortDescendingPriority);\n            this.updateStyles();\n          } else if (!mc.matches && this.activatedBreakpoints.indexOf(bp) !== -1) {\n            // Remove the breakpoint when it's deactivated\n            this.activatedBreakpoints.splice(this.activatedBreakpoints.indexOf(bp), 1);\n            this.activatedBreakpoints.sort(sortDescendingPriority);\n            this.updateStyles();\n          }\n        }\n      }\n      /**\n       * initialize the marshaller with necessary elements for delegation on an element\n       * @param {?} element\n       * @param {?} key\n       * @param {?=} updateFn optional callback so that custom bp directives don't have to re-provide this\n       * @param {?=} clearFn optional callback so that custom bp directives don't have to re-provide this\n       * @param {?=} extraTriggers other triggers to force style updates (e.g. layout, directionality, etc)\n       * @return {?}\n       */\n\n    }, {\n      key: \"init\",\n      value: function init(element, key, updateFn, clearFn) {\n        var extraTriggers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n        initBuilderMap(this.updateMap, element, key, updateFn);\n        initBuilderMap(this.clearMap, element, key, clearFn);\n        this.buildElementKeyMap(element, key);\n        this.watchExtraTriggers(element, key, extraTriggers);\n      }\n      /**\n       * get the value for an element and key and optionally a given breakpoint\n       * @param {?} element\n       * @param {?} key\n       * @param {?=} bp\n       * @return {?}\n       */\n\n    }, {\n      key: \"getValue\",\n      value: function getValue(element, key, bp) {\n        /** @type {?} */\n        var bpMap = this.elementMap.get(element);\n\n        if (bpMap) {\n          /** @type {?} */\n          var values = bp !== undefined ? bpMap.get(bp) : this.getActivatedValues(bpMap, key);\n\n          if (values) {\n            return values.get(key);\n          }\n        }\n\n        return undefined;\n      }\n      /**\n       * whether the element has values for a given key\n       * @param {?} element\n       * @param {?} key\n       * @return {?}\n       */\n\n    }, {\n      key: \"hasValue\",\n      value: function hasValue(element, key) {\n        /** @type {?} */\n        var bpMap = this.elementMap.get(element);\n\n        if (bpMap) {\n          /** @type {?} */\n          var values = this.getActivatedValues(bpMap, key);\n\n          if (values) {\n            return values.get(key) !== undefined || false;\n          }\n        }\n\n        return false;\n      }\n      /**\n       * Set the value for an input on a directive\n       * @param {?} element the element in question\n       * @param {?} key the type of the directive (e.g. flex, layout-gap, etc)\n       * @param {?} val the value for the breakpoint\n       * @param {?} bp the breakpoint suffix (empty string = default)\n       * @return {?}\n       */\n\n    }, {\n      key: \"setValue\",\n      value: function setValue(element, key, val, bp) {\n        /** @type {?} */\n        var bpMap = this.elementMap.get(element);\n\n        if (!bpMap) {\n          bpMap = new Map().set(bp, new Map().set(key, val));\n          this.elementMap.set(element, bpMap);\n        } else {\n          /** @type {?} */\n          var values = (bpMap.get(bp) || new Map()).set(key, val);\n          bpMap.set(bp, values);\n          this.elementMap.set(element, bpMap);\n        }\n        /** @type {?} */\n\n\n        var value = this.getValue(element, key);\n\n        if (value !== undefined) {\n          this.updateElement(element, key, value);\n        }\n      }\n      /**\n       * Track element value changes for a specific key\n       * @param {?} element\n       * @param {?} key\n       * @return {?}\n       */\n\n    }, {\n      key: \"trackValue\",\n      value: function trackValue(element, key) {\n        return this.subject.asObservable().pipe(filter(\n        /**\n        * @param {?} v\n        * @return {?}\n        */\n\n        /**\n        * @param {?} v\n        * @return {?}\n        */\n        function (v) {\n          return v.element === element && v.key === key;\n        }));\n      }\n      /**\n       * update all styles for all elements on the current breakpoint\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateStyles\",\n      value: function updateStyles() {\n        var _this22 = this;\n\n        this.elementMap.forEach(\n        /**\n        * @param {?} bpMap\n        * @param {?} el\n        * @return {?}\n        */\n        function (bpMap, el) {\n          /** @type {?} */\n          var keyMap = new Set(\n          /** @type {?} */\n          _this22.elementKeyMap.get(el));\n          /** @type {?} */\n\n          var valueMap = _this22.getActivatedValues(bpMap);\n\n          if (valueMap) {\n            valueMap.forEach(\n            /**\n            * @param {?} v\n            * @param {?} k\n            * @return {?}\n            */\n            function (v, k) {\n              _this22.updateElement(el, k, v);\n\n              keyMap.delete(k);\n            });\n          }\n\n          keyMap.forEach(\n          /**\n          * @param {?} k\n          * @return {?}\n          */\n\n          /**\n          * @param {?} k\n          * @return {?}\n          */\n          function (k) {\n            valueMap = _this22.getActivatedValues(bpMap, k);\n\n            if (valueMap) {\n              /** @type {?} */\n              var value = valueMap.get(k);\n\n              _this22.updateElement(el, k, value);\n            } else {\n              _this22.clearElement(el, k);\n            }\n          });\n        });\n      }\n      /**\n       * clear the styles for a given element\n       * @param {?} element\n       * @param {?} key\n       * @return {?}\n       */\n\n    }, {\n      key: \"clearElement\",\n      value: function clearElement(element, key) {\n        /** @type {?} */\n        var builders = this.clearMap.get(element);\n\n        if (builders) {\n          /** @type {?} */\n          var clearFn =\n          /** @type {?} */\n          builders.get(key);\n\n          if (!!clearFn) {\n            clearFn();\n            this.subject.next({\n              element: element,\n              key: key,\n              value: ''\n            });\n          }\n        }\n      }\n      /**\n       * update a given element with the activated values for a given key\n       * @param {?} element\n       * @param {?} key\n       * @param {?} value\n       * @return {?}\n       */\n\n    }, {\n      key: \"updateElement\",\n      value: function updateElement(element, key, value) {\n        /** @type {?} */\n        var builders = this.updateMap.get(element);\n\n        if (builders) {\n          /** @type {?} */\n          var updateFn =\n          /** @type {?} */\n          builders.get(key);\n\n          if (!!updateFn) {\n            updateFn(value);\n            this.subject.next({\n              element: element,\n              key: key,\n              value: value\n            });\n          }\n        }\n      }\n      /**\n       * release all references to a given element\n       * @param {?} element\n       * @return {?}\n       */\n\n    }, {\n      key: \"releaseElement\",\n      value: function releaseElement(element) {\n        /** @type {?} */\n        var watcherMap = this.watcherMap.get(element);\n\n        if (watcherMap) {\n          watcherMap.forEach(\n          /**\n          * @param {?} s\n          * @return {?}\n          */\n\n          /**\n          * @param {?} s\n          * @return {?}\n          */\n          function (s) {\n            return s.unsubscribe();\n          });\n          this.watcherMap.delete(element);\n        }\n        /** @type {?} */\n\n\n        var elementMap = this.elementMap.get(element);\n\n        if (elementMap) {\n          elementMap.forEach(\n          /**\n          * @param {?} _\n          * @param {?} s\n          * @return {?}\n          */\n          function (_, s) {\n            return elementMap.delete(s);\n          });\n          this.elementMap.delete(element);\n        }\n      }\n      /**\n       * trigger an update for a given element and key (e.g. layout)\n       * @param {?} element\n       * @param {?=} key\n       * @return {?}\n       */\n\n    }, {\n      key: \"triggerUpdate\",\n      value: function triggerUpdate(element, key) {\n        var _this23 = this;\n\n        /** @type {?} */\n        var bpMap = this.elementMap.get(element);\n\n        if (bpMap) {\n          /** @type {?} */\n          var valueMap = this.getActivatedValues(bpMap, key);\n\n          if (valueMap) {\n            if (key) {\n              this.updateElement(element, key, valueMap.get(key));\n            } else {\n              valueMap.forEach(\n              /**\n              * @param {?} v\n              * @param {?} k\n              * @return {?}\n              */\n              function (v, k) {\n                return _this23.updateElement(element, k, v);\n              });\n            }\n          }\n        }\n      }\n      /**\n       * Cross-reference for HTMLElement with directive key\n       * @private\n       * @param {?} element\n       * @param {?} key\n       * @return {?}\n       */\n\n    }, {\n      key: \"buildElementKeyMap\",\n      value: function buildElementKeyMap(element, key) {\n        /** @type {?} */\n        var keyMap = this.elementKeyMap.get(element);\n\n        if (!keyMap) {\n          keyMap = new Set();\n          this.elementKeyMap.set(element, keyMap);\n        }\n\n        keyMap.add(key);\n      }\n      /**\n       * Other triggers that should force style updates:\n       * - directionality\n       * - layout changes\n       * - mutationobserver updates\n       * @private\n       * @param {?} element\n       * @param {?} key\n       * @param {?} triggers\n       * @return {?}\n       */\n\n    }, {\n      key: \"watchExtraTriggers\",\n      value: function watchExtraTriggers(element, key, triggers) {\n        var _this24 = this;\n\n        if (triggers && triggers.length) {\n          /** @type {?} */\n          var watchers = this.watcherMap.get(element);\n\n          if (!watchers) {\n            watchers = new Map();\n            this.watcherMap.set(element, watchers);\n          }\n          /** @type {?} */\n\n\n          var subscription = watchers.get(key);\n\n          if (!subscription) {\n            /** @type {?} */\n            var newSubscription = merge.apply(void 0, _toConsumableArray(triggers)).subscribe(\n            /**\n            * @return {?}\n            */\n            function () {\n              /** @type {?} */\n              var currentValue = _this24.getValue(element, key);\n\n              _this24.updateElement(element, key, currentValue);\n            });\n            watchers.set(key, newSubscription);\n          }\n        }\n      }\n      /**\n       * Breakpoint locator by mediaQuery\n       * @private\n       * @param {?} query\n       * @return {?}\n       */\n\n    }, {\n      key: \"findByQuery\",\n      value: function findByQuery(query) {\n        return this.breakpoints.findByQuery(query);\n      }\n      /**\n       * get the fallback breakpoint for a given element, starting with the current breakpoint\n       * @private\n       * @param {?} bpMap\n       * @param {?=} key\n       * @return {?}\n       */\n\n    }, {\n      key: \"getActivatedValues\",\n      value: function getActivatedValues(bpMap, key) {\n        for (var i = 0; i < this.activatedBreakpoints.length; i++) {\n          /** @type {?} */\n          var activatedBp = this.activatedBreakpoints[i];\n          /** @type {?} */\n\n          var valueMap = bpMap.get(activatedBp.alias);\n\n          if (valueMap) {\n            if (key === undefined || valueMap.has(key) && valueMap.get(key) != null) {\n              return valueMap;\n            }\n          }\n        }\n        /** @type {?} */\n\n\n        var lastHope = bpMap.get('');\n        return key === undefined || lastHope && lastHope.has(key) ? lastHope : undefined;\n      }\n      /**\n       * Watch for mediaQuery breakpoint activations\n       * @private\n       * @return {?}\n       */\n\n    }, {\n      key: \"observeActivations\",\n      value: function observeActivations() {\n        /** @type {?} */\n        var target =\n        /** @type {?} */\n\n        /** @type {?} */\n        this;\n        /** @type {?} */\n\n        var queries = this.breakpoints.items.map(\n        /**\n        * @param {?} bp\n        * @return {?}\n        */\n\n        /**\n        * @param {?} bp\n        * @return {?}\n        */\n        function (bp) {\n          return bp.mediaQuery;\n        });\n        this.matchMedia.observe(this.hook.withPrintQuery(queries)).pipe(tap(this.hook.interceptEvents(target)), filter(this.hook.blockPropagation())).subscribe(this.onMediaChange.bind(this));\n      }\n    }]);\n\n    return MediaMarshaller;\n  }();\n\n  MediaMarshaller.ɵfac = function MediaMarshaller_Factory(t) {\n    return new (t || MediaMarshaller)(ɵngcc0.ɵɵinject(MatchMedia), ɵngcc0.ɵɵinject(BreakPointRegistry), ɵngcc0.ɵɵinject(PrintHook));\n  };\n  /** @nocollapse */\n\n\n  MediaMarshaller.ɵprov = ɵɵdefineInjectable({\n    factory: function MediaMarshaller_Factory() {\n      return new MediaMarshaller(ɵɵinject(MatchMedia), ɵɵinject(BreakPointRegistry), ɵɵinject(PrintHook));\n    },\n    token: MediaMarshaller,\n    providedIn: \"root\"\n  });\n  return MediaMarshaller;\n}();\n/**\n * @param {?} map\n * @param {?} element\n * @param {?} key\n * @param {?=} input\n * @return {?}\n */\n\n\nfunction initBuilderMap(map$$1, element, key, input) {\n  if (input !== undefined) {\n    /** @type {?} */\n    var oldMap = map$$1.get(element);\n\n    if (!oldMap) {\n      oldMap = new Map();\n      map$$1.set(element, oldMap);\n    }\n\n    oldMap.set(key, input);\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: core/public-api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: core/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { MatchMedia as ɵMatchMedia, MockMatchMedia as ɵMockMatchMedia, MockMatchMediaProvider as ɵMockMatchMediaProvider, CoreModule, removeStyles, BROWSER_PROVIDER, CLASS_NAME, MediaChange, StylesheetMap, DEFAULT_CONFIG, LAYOUT_CONFIG, SERVER_TOKEN, BREAKPOINT, mergeAlias, BaseDirective2, DEFAULT_BREAKPOINTS, ScreenTypes, ORIENTATION_BREAKPOINTS, BreakPointRegistry, BREAKPOINTS, MediaObserver, MediaTrigger, sortDescendingPriority, sortAscendingPriority, coerceArray, StyleUtils, StyleBuilder, validateBasis, MediaMarshaller, BREAKPOINT_PRINT, PrintHook };","map":null,"metadata":{},"sourceType":"module"}