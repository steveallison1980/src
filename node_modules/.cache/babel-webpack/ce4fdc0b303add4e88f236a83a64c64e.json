{"ast":null,"code":"import _classCallCheck from \"c:/PROJECTS/WEBSITE/newtest/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, NgZone, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { Subject, of, Observable, from, merge } from 'rxjs';\nimport { observeOn, switchMap, map, shareReplay, first, switchMapTo, subscribeOn, filter } from 'rxjs/operators';\nimport { ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory, ɵfirebaseAppFactory, ɵfetchInstance, ɵlazySDKProxy, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵapplyMixins } from '@angular/fire';\nimport { isPlatformServer } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * Generated from: base.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nvar proxyPolyfillCompat = {\n  app: null,\n  applyActionCode: null,\n  checkActionCode: null,\n  confirmPasswordReset: null,\n  createUserWithEmailAndPassword: null,\n  currentUser: null,\n  fetchSignInMethodsForEmail: null,\n  isSignInWithEmailLink: null,\n  getRedirectResult: null,\n  languageCode: null,\n  settings: null,\n  onAuthStateChanged: null,\n  onIdTokenChanged: null,\n  sendSignInLinkToEmail: null,\n  sendPasswordResetEmail: null,\n  setPersistence: null,\n  signInAndRetrieveDataWithCredential: null,\n  signInAnonymously: null,\n  signInWithCredential: null,\n  signInWithCustomToken: null,\n  signInWithEmailAndPassword: null,\n  signInWithPhoneNumber: null,\n  signInWithEmailLink: null,\n  signInWithPopup: null,\n  signInWithRedirect: null,\n  signOut: null,\n  tenantId: null,\n  updateCurrentUser: null,\n  useDeviceLanguage: null,\n  useEmulator: null,\n  verifyPasswordResetCode: null\n};\n/**\n * @fileoverview added by tsickle\n * Generated from: auth.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// WARNING: interface has both a type and a value, skipping emit\n\n/** @type {?} */\n\nvar USE_EMULATOR = new InjectionToken('angularfire2.auth.use-emulator');\n/** @type {?} */\n\nvar SETTINGS = new InjectionToken('angularfire2.auth.settings');\n/** @type {?} */\n\nvar TENANT_ID = new InjectionToken('angularfire2.auth.tenant-id');\n/** @type {?} */\n\nvar LANGUAGE_CODE = new InjectionToken('angularfire2.auth.langugage-code');\n/** @type {?} */\n\nvar USE_DEVICE_LANGUAGE = new InjectionToken('angularfire2.auth.use-device-language');\n/** @type {?} */\n\nvar PERSISTENCE = new InjectionToken('angularfire.auth.persistence');\n\nvar AngularFireAuth = /*@__PURE__*/function () {\n  var AngularFireAuth =\n  /**\n   * @param {?} options\n   * @param {?} nameOrConfig\n   * @param {?} platformId\n   * @param {?} zone\n   * @param {?} _useEmulator\n   * @param {?} _settings\n   * @param {?} tenantId\n   * @param {?} languageCode\n   * @param {?} useDeviceLanguage\n   * @param {?} persistence\n   */\n  function AngularFireAuth(options, nameOrConfig, // tslint:disable-next-line:ban-types\n  platformId, zone, _useEmulator, // can't use the tuple here\n  _settings, // can't use firebase.auth.AuthSettings here\n  tenantId, languageCode, useDeviceLanguage, persistence) {\n    _classCallCheck(this, AngularFireAuth);\n\n    /** @type {?} */\n    var schedulers = new ɵAngularFireSchedulers(zone);\n    /** @type {?} */\n\n    var keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(schedulers);\n    /** @type {?} */\n\n    var logins = new Subject();\n    /** @type {?} */\n\n    var auth = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(\n    /**\n    * @return {?}\n    */\n    function () {\n      return zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        return import('firebase/auth');\n      });\n    }), map(\n    /**\n    * @return {?}\n    */\n    function () {\n      return ɵfirebaseAppFactory(options, zone, nameOrConfig);\n    }), map(\n    /**\n    * @param {?} app\n    * @return {?}\n    */\n\n    /**\n    * @param {?} app\n    * @return {?}\n    */\n    function (app) {\n      return zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      function () {\n        /** @type {?} */\n        var useEmulator = _useEmulator;\n        /** @type {?} */\n\n        var settings = _settings;\n        return ɵfetchInstance(\"\".concat(app.name, \".auth\"), 'AngularFireAuth', app,\n        /**\n        * @return {?}\n        */\n        function () {\n          /** @type {?} */\n          var auth = zone.runOutsideAngular(\n          /**\n          * @return {?}\n          */\n          function () {\n            return app.auth();\n          });\n\n          if (useEmulator) {\n            // Firebase Auth doesn't conform to the useEmulator convention, let's smooth that over\n            auth.useEmulator(\"http://\".concat(useEmulator.join(':')));\n          }\n\n          if (tenantId) {\n            auth.tenantId = tenantId;\n          }\n\n          auth.languageCode = languageCode;\n\n          if (useDeviceLanguage) {\n            auth.useDeviceLanguage();\n          }\n\n          if (settings) {\n            auth.settings = settings;\n          }\n\n          if (persistence) {\n            auth.setPersistence(persistence);\n          }\n\n          return auth;\n        }, [useEmulator, tenantId, languageCode, useDeviceLanguage, settings, persistence]);\n      });\n    }), shareReplay({\n      bufferSize: 1,\n      refCount: false\n    }));\n\n    if (isPlatformServer(platformId)) {\n      this.authState = this.user = this.idToken = this.idTokenResult = this.credential = of(null);\n    } else {\n      // HACK, as we're exporting auth.Auth, rather than auth, developers importing firebase.auth\n      //       (e.g, `import { auth } from 'firebase/app'`) are getting an undefined auth object unexpectedly\n      //       as we're completely lazy. Let's eagerly load the Auth SDK here.\n      //       There could potentially be race conditions still... but this greatly decreases the odds while\n      //       we reevaluate the API.\n\n      /** @type {?} */\n      var _ = auth.pipe(first()).subscribe();\n      /** @type {?} */\n\n\n      var redirectResult = auth.pipe(switchMap(\n      /**\n      * @param {?} auth\n      * @return {?}\n      */\n\n      /**\n      * @param {?} auth\n      * @return {?}\n      */\n      function (auth) {\n        return auth.getRedirectResult().then(\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n\n        /**\n        * @param {?} it\n        * @return {?}\n        */\n        function (it) {\n          return it;\n        },\n        /**\n        * @return {?}\n        */\n        function () {\n          return null;\n        });\n      }), keepUnstableUntilFirst, shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      /** @type {?} */\n\n      var fromCallback =\n      /**\n      * @template T\n      * @param {?} cb\n      * @return {?}\n      */\n      function fromCallback(cb) {\n        return new Observable(\n        /**\n        * @param {?} subscriber\n        * @return {?}\n        */\n\n        /**\n        * @param {?} subscriber\n        * @return {?}\n        */\n        function (subscriber) {\n          return {\n            unsubscribe: zone.runOutsideAngular(\n            /**\n            * @return {?}\n            */\n            function () {\n              return cb(subscriber);\n            })\n          };\n        });\n      };\n      /** @type {?} */\n\n\n      var authStateChanged = auth.pipe(switchMap(\n      /**\n      * @param {?} auth\n      * @return {?}\n      */\n\n      /**\n      * @param {?} auth\n      * @return {?}\n      */\n      function (auth) {\n        return fromCallback(auth.onAuthStateChanged.bind(auth));\n      }));\n      /** @type {?} */\n\n      var idTokenChanged = auth.pipe(switchMap(\n      /**\n      * @param {?} auth\n      * @return {?}\n      */\n\n      /**\n      * @param {?} auth\n      * @return {?}\n      */\n      function (auth) {\n        return fromCallback(auth.onIdTokenChanged.bind(auth));\n      }));\n      this.authState = redirectResult.pipe(switchMapTo(authStateChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      this.user = redirectResult.pipe(switchMapTo(idTokenChanged), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      this.idToken = this.user.pipe(switchMap(\n      /**\n      * @param {?} user\n      * @return {?}\n      */\n\n      /**\n      * @param {?} user\n      * @return {?}\n      */\n      function (user) {\n        return user ? from(user.getIdToken()) : of(null);\n      }));\n      this.idTokenResult = this.user.pipe(switchMap(\n      /**\n      * @param {?} user\n      * @return {?}\n      */\n\n      /**\n      * @param {?} user\n      * @return {?}\n      */\n      function (user) {\n        return user ? from(user.getIdTokenResult()) : of(null);\n      }));\n      this.credential = merge(redirectResult, logins, // pipe in null authState to make credential zipable, just a weird devexp if\n      // authState and user go null to still have a credential\n      this.authState.pipe(filter(\n      /**\n      * @param {?} it\n      * @return {?}\n      */\n\n      /**\n      * @param {?} it\n      * @return {?}\n      */\n      function (it) {\n        return !it;\n      }))).pipe( // handle the { user: { } } when a user is already logged in, rather have null\n      // TODO handle the type corcersion better\n      map(\n      /**\n      * @param {?} credential\n      * @return {?}\n      */\n\n      /**\n      * @param {?} credential\n      * @return {?}\n      */\n      function (credential) {\n        return (credential === null || credential === void 0 ? void 0 : credential.user) ?\n        /** @type {?} */\n        credential : null;\n      }), subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n    }\n\n    return ɵlazySDKProxy(this, auth, zone, {\n      spy: {\n        apply:\n        /**\n        * @param {?} name\n        * @param {?} _\n        * @param {?} val\n        * @return {?}\n        */\n        function apply(name, _, val) {\n          // If they call a signIn or createUser function listen into the promise\n          // this will give us the user credential, push onto the logins Subject\n          // to be consumed in .credential\n          if (name.startsWith('signIn') || name.startsWith('createUser')) {\n            // TODO fix the types, the trouble is UserCredential has everything optional\n            val.then(\n            /**\n            * @param {?} user\n            * @return {?}\n            */\n            function (user) {\n              return logins.next(\n              /** @type {?} */\n              user);\n            });\n          }\n        }\n      }\n    });\n  };\n\n  AngularFireAuth.ɵfac = function AngularFireAuth_Factory(t) {\n    return new (t || AngularFireAuth)(ɵngcc0.ɵɵinject(FIREBASE_OPTIONS), ɵngcc0.ɵɵinject(FIREBASE_APP_NAME, 8), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(USE_EMULATOR, 8), ɵngcc0.ɵɵinject(SETTINGS, 8), ɵngcc0.ɵɵinject(TENANT_ID, 8), ɵngcc0.ɵɵinject(LANGUAGE_CODE, 8), ɵngcc0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), ɵngcc0.ɵɵinject(PERSISTENCE, 8));\n  };\n  /** @nocollapse */\n\n\n  AngularFireAuth.ɵprov = ɵɵdefineInjectable({\n    factory: function AngularFireAuth_Factory() {\n      return new AngularFireAuth(ɵɵinject(FIREBASE_OPTIONS), ɵɵinject(FIREBASE_APP_NAME, 8), ɵɵinject(PLATFORM_ID), ɵɵinject(NgZone), ɵɵinject(USE_EMULATOR, 8), ɵɵinject(SETTINGS, 8), ɵɵinject(TENANT_ID, 8), ɵɵinject(LANGUAGE_CODE, 8), ɵɵinject(USE_DEVICE_LANGUAGE, 8), ɵɵinject(PERSISTENCE, 8));\n    },\n    token: AngularFireAuth,\n    providedIn: \"any\"\n  });\n  return AngularFireAuth;\n}();\n\nif (false) {\n  /**\n   * Observable of authentication state; as of Firebase 4.0 this is only triggered via sign-in/out\n   * @type {?}\n   */\n  AngularFireAuth.prototype.authState;\n  /**\n   * Observable of the currently signed-in user's JWT token used to identify the user to a Firebase service (or null).\n   * @type {?}\n   */\n\n  AngularFireAuth.prototype.idToken;\n  /**\n   * Observable of the currently signed-in user (or null).\n   * @type {?}\n   */\n\n  AngularFireAuth.prototype.user;\n  /**\n   * Observable of the currently signed-in user's IdTokenResult object which contains the ID token JWT string and other\n   * helper properties for getting different data associated with the token as well as all the decoded payload claims\n   * (or null).\n   * @type {?}\n   */\n\n  AngularFireAuth.prototype.idTokenResult;\n  /**\n   * Observable of the currently signed-in user's credential, or null\n   * @type {?}\n   */\n\n  AngularFireAuth.prototype.credential;\n}\n\nɵapplyMixins(AngularFireAuth, [proxyPolyfillCompat]);\n\nvar AngularFireAuthModule = /*@__PURE__*/function () {\n  var AngularFireAuthModule = function AngularFireAuthModule() {\n    _classCallCheck(this, AngularFireAuthModule);\n  };\n\n  AngularFireAuthModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n    type: AngularFireAuthModule\n  });\n  AngularFireAuthModule.ɵinj = ɵngcc0.ɵɵdefineInjector({\n    factory: function AngularFireAuthModule_Factory(t) {\n      return new (t || AngularFireAuthModule)();\n    },\n    providers: [AngularFireAuth]\n  });\n  return AngularFireAuthModule;\n}();\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-fire-auth.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AngularFireAuth, AngularFireAuthModule, LANGUAGE_CODE, PERSISTENCE, SETTINGS, TENANT_ID, USE_DEVICE_LANGUAGE, USE_EMULATOR };","map":null,"metadata":{},"sourceType":"module"}